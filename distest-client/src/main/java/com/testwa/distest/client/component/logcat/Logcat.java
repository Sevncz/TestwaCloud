package com.testwa.distest.client.component.logcat;import com.github.cosysoft.device.android.AndroidDevice;import com.testwa.core.service.AdbDriverService;import com.testwa.core.service.LogcatServiceBuilder;import com.testwa.distest.client.android.AndroidHelper;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.io.*;import java.util.ArrayList;import java.util.List;@Data@Slf4jpublic class Logcat {    private List<LogcatListener> listenerList = new ArrayList<>();    private AdbDriverService service;    private String serialNumber;    private String content;    private PipedOutputStream pipedOS = new PipedOutputStream();    private boolean keepRunning = true;    private ByteArrayOutputStream byteArrayOS =            new ByteArrayOutputStream() {                public void close() {                    keepRunning = false;                    try {                        super.close();                        pipedOS.close();                    } catch(IOException e) {                        log.error("close byteArrayOS error", e);                    }                }            };    private PipedInputStream pipedIS = new PipedInputStream() {        public void close() {            keepRunning = false;            try {                super.close();            } catch(IOException e) {                log.error("close pipedIS error", e);            }        }    };    private Thread startByteArrayReaderThread;    private Thread startReadLogcatThread;    public Logcat(String serialNumber, String content) {        this.serialNumber = serialNumber;        this.content = content;        try {            pipedOS.connect(pipedIS);        } catch (IOException e) {            log.error("connect outputStream error");        }    }    public void start(){        clear();        try {            Thread.sleep(1000);        } catch (InterruptedException e) {        }        this.service = new LogcatServiceBuilder()                .withDeviceId(this.serialNumber)                .withContent(content)                .build();        this.service.addOutPutStream(byteArrayOS);        this.service.start();        onStartup(true);        this.startByteArrayReaderThread = new Thread(new StartByteArrayReaderInitial());        this.startByteArrayReaderThread.start();        this.startReadLogcatThread = new Thread(new StartReadLogcatInitial());        this.startReadLogcatThread.start();    }    private void clear() {        new LogcatServiceBuilder()                .withDeviceId(this.serialNumber)                .withClear()                .build().start();    }    class StartByteArrayReaderInitial implements Runnable {        public void run() {            while(keepRunning){                // 检查流里面的字节数                if(byteArrayOS.size() > 0) {                    byte[] buffer = null;                    synchronized(byteArrayOS) {                        buffer = byteArrayOS.toByteArray();                        byteArrayOS.reset(); // 清除缓冲区                    }                    try {                        // 把提取到的数据发送给PipedOutputStream                        pipedOS.write(buffer, 0, buffer.length);                    } catch(IOException e) {                        log.error("write to input error", e);                    }                }else {// 没有数据可用，线程进入睡眠状态                    try {                        // 每隔1秒查看ByteArrayOutputStream检查新数据                        Thread.sleep(1000);                    }                    catch(InterruptedException e) {}                }            }            try {                getOutputStream().close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    class StartReadLogcatInitial implements Runnable {        public void run() {            while(keepRunning){                byte[] buf=new byte[2048];                try {                    pipedIS.read(buf);                    onLog(buf);                } catch (IOException e) {                    e.printStackTrace();                }            }            try {                getInputStream().close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    private InputStream getInputStream() {        return pipedIS;    }    private OutputStream getOutputStream() {        return byteArrayOS;    }    public void close() {        log.info("logcat close");        this.keepRunning = false;        this.service.stop();        this.onClose();    }    public void addEventListener(LogcatListener listener) {        if (listener != null) {            this.listenerList.add(listener);        }    }    private void onStartup(boolean success) {        for (LogcatListener listener : listenerList) {            listener.onStartup(this, success);        }    }    private void onClose() {        for (LogcatListener listener : listenerList) {            listener.onClose(this);        }    }    private void onLog(byte[] data) {        for (LogcatListener listener : listenerList) {            listener.onLog(this, data);        }    }}