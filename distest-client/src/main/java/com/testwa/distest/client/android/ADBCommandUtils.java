package com.testwa.distest.client.android;import com.github.cosysoft.device.android.AndroidApp;import com.github.cosysoft.device.android.impl.DefaultAndroidApp;import com.github.cosysoft.device.shell.AndroidSdk;import com.testwa.core.shell.UTF8CommonExecs;import com.testwa.core.utils.TimeUtil;import com.testwa.distest.client.component.Constant;import com.testwa.distest.client.component.FlowResult;import com.testwa.distest.client.component.StepResult;import com.testwa.distest.client.component.appium.utils.Config;import com.testwa.distest.client.component.port.ApkPortProvider;import com.testwa.distest.client.component.stfagent.KeyCode;import com.testwa.distest.client.exception.InstallAppException;import com.testwa.distest.client.exception.LaunchAppException;import com.testwa.distest.client.exception.TestcaseRunningException;import io.rpc.testwa.task.StepRequest;import lombok.extern.slf4j.Slf4j;import org.apache.commons.exec.CommandLine;import org.apache.commons.lang3.StringUtils;import org.bytedeco.javacv.FrameFilter;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.math.BigDecimal;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.concurrent.TimeUnit;import java.util.regex.Matcher;import java.util.regex.Pattern;import static org.apache.commons.exec.ExecuteWatchdog.INFINITE_TIMEOUT;/** * @Program: distest * @Description: 把adb的一些常用操作集合起来 * @Author: wen * @Create: 2018-05-17 20:54 **/@Slf4jpublic class ADBCommandUtils {    private static final String SDCARD_DIR = "/sdcard";    private static final String MAX_SCREEN = "max-screen";    private static final String CRASH_LOG = "/sdcard/crash-dump.log";    public static CommandLine getADBCommandLine(String deviceId) {        CommandLine commandLine = new CommandLine(AndroidSdk.adb());        commandLine.addArgument("-s");        commandLine.addArgument(deviceId);        return commandLine;    }    public static void restart() {        CommandLine commandLine = new CommandLine(AndroidSdk.adb());        commandLine.addArgument("kill-server");        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.exec();        } catch (IOException e) {            log.error("kill adb server error", e);        }        commandLine = new CommandLine(AndroidSdk.adb());        commandLine.addArgument("start-server");        adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.exec();        } catch (IOException e) {            log.error("start adb server error", e);        }    }    public static String command(String deviceId, String[] command) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArguments(command);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.exec();        } catch (IOException e) {            log.error("adb command error\n,{}\n {}\n {}", commandLine.toString(), adbexe.getOutput(), adbexe.getError());        }        return StringUtils.trim(adbexe.getOutput());    }    public static PhysicalSize getPhysicalSize(String deviceId) {        String ret = command(deviceId, new String[]{"wm", "size"});        String retLine = ret.split("\n")[0];        String[] px = StringUtils.substringAfter(retLine, ":").split("x");        int x = 0;        int y = 0;        if(px.length == 2) {            try {                x = Integer.parseInt(px[0].trim());                y = Integer.parseInt(px[1].trim());            }catch (Exception e) {                log.error("getPhysicalSize error, [adb -s {} shell wm size] return [{}]", deviceId, ret, e.getMessage());            }        }        return new PhysicalSize(x, y);    }    public static String getAbi(String deviceId) {        return command(deviceId, new String[]{"getprop", "ro.product.cpu.abi"});    }    public static int getApi(String deviceId) {        return Integer.parseInt(command(deviceId, new String[]{"getprop", "ro.build.version.sdk"}));    }    public static void forwardAbstract(String deviceId, int local, String abstractName) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("forward");        commandLine.addArgument("tcp:" + local);        commandLine.addArgument("localabstract:" + abstractName);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.exec();        } catch (IOException e) {            log.error("forword port error", e);        }    }    public static int forwardTcp(String deviceId, int remote) {        int local = ApkPortProvider.pullPort();        forwardTcp(deviceId, local, remote);        return local;    }    public static int forwardTcp(String deviceId, int local, int remote) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("forward");        commandLine.addArgument("tcp:" + local);        commandLine.addArgument("tcp:" + remote);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.exec();        } catch (IOException e) {            log.error("forword port error", e);        }        return local;    }    public static void removeForward(String deviceId, int port) {        ApkPortProvider.pushPort(port);        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("forward");        commandLine.addArgument("--remove");        commandLine.addArgument("tcp:" + port);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            log.warn("Remove forword port {}", port);            adbexe.exec();        } catch (IOException e) {        }    }    public static StepResult installApp(String deviceId, String appLocalPath) {        StepResult stepResult = new StepResult(StepRequest.StepAction.installApp);        if(StringUtils.isBlank(appLocalPath)) {            log.error("应用文件{}不存在", appLocalPath);            stepResult.setStatus(StepRequest.StepStatus.FAIL);            stepResult.setErrormsg("应用文件不存在");            return stepResult;        }        // 先把 apk push 到设备        String remoteApkFile = SDCARD_DIR + "/" + Paths.get(appLocalPath).getFileName().toString();        pushFile(deviceId, appLocalPath, remoteApkFile);        // 安装设备上的 apk        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("pm");        commandLine.addArgument("install");        commandLine.addArgument("-r");        commandLine.addArgument(remoteApkFile);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        Long start = TimeUtil.getTimestampLong();        try {            adbexe.setTimeout(INFINITE_TIMEOUT);            adbexe.exec();            String output = adbexe.getOutput();            output = output.trim();            if(output.contains("failed to install")) {                String error = adbexe.getError();                stepResult.setStatus(StepRequest.StepStatus.FAIL);                stepResult.setErrormsg(error + "\n" + output);                log.error("安装 app 失败 cmd: {}  error: {} ", commandLine.toString(), error);            }        } catch (IOException e) {            String error = adbexe.getError();            String output = adbexe.getOutput();            stepResult.setStatus(StepRequest.StepStatus.FAIL);            stepResult.setErrormsg(error + "\n" + output);            log.error("安装 app 错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), error + "\n" + output, e.getMessage());        } finally {            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("install apk return {}, time {}ms", output.trim(), end-start);            stepResult.setTotalTime(end - start);        }        return stepResult;    }    public static StepResult launcherApp(String deviceId, String appLocalPath) {        StepResult stepResult = new StepResult(StepRequest.StepAction.launch);        Path appPath = Paths.get(appLocalPath);        AndroidApp androidApp = new DefaultAndroidApp(appPath.toFile());        int exitValue = 0;        if( StringUtils.isBlank(androidApp.getBasePackage()) ){            log.error("{} 启动失败，BasePackage找不到, app路径: {}", deviceId, appLocalPath);            stepResult.setErrormsg("应用BasePackage找不到");            stepResult.setStatus(StepRequest.StepStatus.FAIL);            return stepResult;        }        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("monkey");        commandLine.addArgument("-p");        commandLine.addArgument(androidApp.getBasePackage());        commandLine.addArgument("-c");        commandLine.addArgument("android.intent.category.LAUNCHER");        commandLine.addArgument("1");//        if( StringUtils.isBlank(androidApp.getMainActivity()) ){//            commandLine.addArgument("shell");//            commandLine.addArgument("monkey");//            commandLine.addArgument("-p");//            commandLine.addArgument(androidApp.getBasePackage());//            commandLine.addArgument("-c");//            commandLine.addArgument("android.intent.category.LAUNCHER");//            commandLine.addArgument("1");//        }else{//            String mainActivity = androidApp.getMainActivity().replace(androidApp.getBasePackage(), "");//            String launcherParam = androidApp.getBasePackage() + "/" + mainActivity;//            commandLine.addArgument("shell");//            commandLine.addArgument("am");//            commandLine.addArgument("start");//            commandLine.addArgument("-W");//            commandLine.addArgument("-n");//            commandLine.addArgument(launcherParam);//        }        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        Long start = TimeUtil.getTimestampLong();        try {            adbexe.setTimeout(INFINITE_TIMEOUT);            adbexe.exec();            stepResult.setStatus(StepRequest.StepStatus.SUCCESS);        } catch (IOException e) {            log.error(e.getMessage());            stepResult.setStatus(StepRequest.StepStatus.FAIL);        }finally {//            getLauncherResult(deviceId, stepResult, start, output);            Long end = TimeUtil.getTimestampLong();            stepResult.setTotalTime(end - start);        }        String output = adbexe.getOutput();        log.info("设备 {} 启动 {} 时长：{}  输出: {}", deviceId, androidApp.getBasePackage(), stepResult.getTotalTime(), output);        return stepResult;    }    private static void getLauncherResult(String deviceId, StepResult stepResult, Long start, String output) {        Long end = TimeUtil.getTimestampLong();        String[] result = output.split("\n");        for(String l : result){            if(l.startsWith("Status")){                String[] lineSplit = l.split(":");                String status = lineSplit[1].trim();                if("ok".equals(status)){                    stepResult.setStatus(StepRequest.StepStatus.SUCCESS);                }else{                    stepResult.setStatus(StepRequest.StepStatus.FAIL);                }            }            if(l.startsWith("TotalTime")){                String[] lineSplit = l.split(":");                String totalTimeStr = lineSplit[1].trim();                Long totalTime = Long.parseLong(totalTimeStr);                stepResult.setTotalTime(totalTime);            }            if(l.startsWith("Error")){                log.info("设备 {} 启动失败，{}", deviceId, output);                stepResult.setErrormsg(output);                stepResult.setStatus(StepRequest.StepStatus.FAIL);                break;            }        }        if(stepResult.getTotalTime() == null) {            log.warn("设备启动 TotalTime 未找到 {}", output);            stepResult.setTotalTime(end - start);        }    }    /**     *@Description: 根据 basepackage 获得 Activity 列表     *@Param: [deviceId, basePackage]     *@Return: java.util.List<java.lang.String>     *@Author: wen     *@Date: 2018/6/13     */    public static List<String> getPackageActivityList(String deviceId, String basePackage) {        List<String> activityList = new ArrayList<>();        Runtime runtime = Runtime.getRuntime();        try {            Process process = runtime.exec(AndroidSdk.adb().toString() + " -s "+ deviceId +" shell dumpsys package | grep -i " + basePackage + " | grep Activity");            BufferedReader stdoutReader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));            BufferedReader stderrReader = new BufferedReader(new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8));            String line;            while ((line = stdoutReader.readLine()) != null) {                log.info(line);                if(StringUtils.isNotBlank(line)) {                    String[] fs = line.split("\\s+");                    for (String f : fs) {                        if(f.trim().endsWith("Activity")){                            activityList.add(f.trim());                        }                    }                }            }            while ((line = stderrReader.readLine()) != null) {                log.error(line);            }            int exitVal = process.waitFor();        } catch (IOException e) {            e.printStackTrace();        } catch (InterruptedException e) {            e.printStackTrace();        }        return activityList;    }    public static StepResult uninstallApp(String deviceId, String basePackage) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("uninstall");        commandLine.addArgument(basePackage);        StepResult stepResult = new StepResult(StepRequest.StepAction.uninstallApp);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        Long start = TimeUtil.getTimestampLong();        try {            adbexe.exec();        } catch (IOException e) {            String error = adbexe.getError();            String output = adbexe.getOutput();            stepResult.setStatus(StepRequest.StepStatus.FAIL);            stepResult.setErrormsg(error + "\n" + output);            log.error("卸载 App 错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        } finally {            Long end = TimeUtil.getTimestampLong();            stepResult.setTotalTime(end - start);            log.info("卸载 App 完成 cmd: {}, time {}ms", commandLine.toString(), end-start);        }        return stepResult;    }    public static StepResult uninstallAppPath(String deviceId, String appLocalPath) {        AndroidApp androidApp = new DefaultAndroidApp(new File(appLocalPath));        return uninstallApp(deviceId, androidApp.getBasePackage());    }    public static void inputTextADBKeyBoard(String deviceId, String text, Long timeout) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("am");        commandLine.addArgument("broadcast");        commandLine.addArgument("-a");        commandLine.addArgument("ADB_INPUT_TEXT");        commandLine.addArgument("--es");        commandLine.addArgument("msg");        commandLine.addArgument(text);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.setTimeout(timeout);            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("input text ADBKeyBoard return {}, time {}ms", output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("输入文字内容错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static void inputTextOriginal(String deviceId, String text, Long timeout) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("input");        commandLine.addArgument("text");        commandLine.addArgument(text);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.setTimeout(timeout);            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("input text original return {}, time {}ms", output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("输入文字内容错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static void inputCode(String deviceId, int code) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("input");        commandLine.addArgument("keyevent");        commandLine.addArgument(String.valueOf(code));        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("input code return {}, time {}ms", output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("输入 adb code 错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static void inputCodeADBKeyBoard(String deviceId, int code, Long timeout) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("am");        commandLine.addArgument("broadcast");        commandLine.addArgument("-a");        commandLine.addArgument("ADB_INPUT_CODE");        commandLine.addArgument("--ei");        commandLine.addArgument("code");        commandLine.addArgument(String.valueOf(code));        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.setTimeout(timeout);            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.info("input code ADBKeyBoard return {}, time {}ms", output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("ADB 命令执行失败 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static void switchADBKeyBoard(String deviceId) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("ime");        commandLine.addArgument("set");        commandLine.addArgument("com.android.adbkeyboard/.AdbIME");        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("switch to ADBKeyBoard  {}, time {}ms", output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("切换 ADBKeyBoard 输入法错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static void switchOriginalKeyboard(String deviceId) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("ime");        commandLine.addArgument("set");        commandLine.addArgument("com.nuance.swype.dtc/com.nuance.swype.input.IME");        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("switch back to original virtual keyboard {}, time {}ms", output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("ADB 命令执行失败 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static void openWeb(String deviceId, String url) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("am");        commandLine.addArgument("start");        commandLine.addArgument("-a");        commandLine.addArgument("android.intent.action.VIEW");        commandLine.addArgument("-d");        commandLine.addArgument(url);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("{} return {}, time {}ms", commandLine.toString(), output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("打开网页错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static void shell(String deviceId, String shellcmd) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument(shellcmd);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            adbexe.setTimeout(5000L);            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("{} return {}, time {}ms", commandLine.toString(), output.trim(), end-start);        } catch (IOException e) {            String error = adbexe.getError();            log.error("ADB 命令执行失败 cmd: {}  error: {}  exception: {}", commandLine.toString(), error, e.getMessage());        }    }    public static boolean isInstalledApp(String deviceId, String appLocalPath) {        AndroidApp androidApp = new DefaultAndroidApp(new File(appLocalPath));        return isInstalledBasepackage(deviceId, androidApp.getBasePackage());    }    public static boolean isInstalledBasepackage(String deviceId, String basepackage) {        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("pm");        commandLine.addArgument("list");        commandLine.addArgument("packages");        commandLine.addArgument(basepackage);        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        try {            Long start = TimeUtil.getTimestampLong();            adbexe.exec();            String output = adbexe.getOutput();            Long end = TimeUtil.getTimestampLong();            log.debug("{} return {}, time {}ms", commandLine.toString(), output.trim(), end-start);            if(StringUtils.isNotBlank(output) && output.contains(basepackage)){                return true;            }        } catch (IOException e) {            String output = adbexe.getOutput();            String error = adbexe.getError();            log.error("获得安装应用列表错误 cmd: {}  error: {}  exception: {}", commandLine.toString(), output + "#########" + error, e.getMessage());        }        return false;    }    /**     *@Description: 1、创建文件夹；     *              2、push Maxim.jar；     *              3、run；     *              4、pull截图     *              adb shell CLASSPATH=/sdcard/monkey.jar:/sdcard/framework.jar exec app_process /system/bin tv.panda.test.monkey.Monkey -p so.ofo.labofo --uiautomatormix --running-minutes 1 -v -v --throttle 2000 --output-directory /sdcard/max-screen/     *@Param: [deviceId, appid, runningTime]     *@Return: java.lang.String     *@Author: wen     *@Date: 2018/5/21     */    public static String monkey(String deviceId, String appid, int runningTime) throws TestcaseRunningException {        String resourcesPath = Config.getString("distest.agent.resources");        Path localPullDir = Paths.get(Constant.AGENT_TMP_DIR, deviceId, TimeUtil.getTimestampForFile());        Path maximDir = Paths.get(resourcesPath, Constant.MAXIM_BIN);        try {            Files.list(maximDir).forEach( p -> {                pushFile(deviceId, p.toString(), SDCARD_DIR + "/" + p.getFileName().toString());            });        } catch (IOException e) {            log.error("遍历文件夹错误, {}, error: {}", maximDir.toString(), e.getMessage());        }        String outputdir = SDCARD_DIR + "/" + MAX_SCREEN + "/";        removeDir(deviceId, outputdir);        CommandLine commandLine = getADBCommandLine(deviceId);        commandLine.addArgument("shell");        commandLine.addArgument("CLASSPATH=/sdcard/monkey.jar:/sdcard/framework.jar");        commandLine.addArgument("exec");        commandLine.addArgument("app_process");        commandLine.addArgument("/system/bin");        commandLine.addArgument("tv.panda.test.monkey.Monkey");        commandLine.addArgument("-p");        commandLine.addArgument(appid);        // 可以切换遍历模式，这里改用深度优先遍历 Android 5不支持 dfs mode        commandLine.addArgument("--uiautomatormix");//        commandLine.addArgument("--uiautomatordfs");        commandLine.addArgument("--running-minutes");        commandLine.addArgument(String.valueOf(runningTime));//        commandLine.addArgument("-v");//        commandLine.addArgument("-v");        commandLine.addArgument("--throttle");        commandLine.addArgument("600");        commandLine.addArgument("--output-directory");        commandLine.addArgument(outputdir);//        commandLine.addArgument("--imagepolling");        UTF8CommonExecs adbexe = new UTF8CommonExecs(commandLine);        Long start = TimeUtil.getTimestampLong();        try {//            adbexe.setTimeout((runningTime + 1) * 60 * 1000L);            adbexe.setTimeout(INFINITE_TIMEOUT);            log.info("设备 {} 开始随机点击测试", deviceId);            adbexe.exec();        } catch (IOException e) {            log.error("monkey runner {} error", commandLine.toString(), e);        } finally {            Long end = TimeUtil.getTimestampLong();            String output = adbexe.getOutput();            // 再增加20秒的缓冲时间            if((end - start) <= (runningTime * 60 - 3) * 1000){                log.error("随机点击测试时长少于预定时间，执行错误, {}, \n{}", output, commandLine.toString());                throw new TestcaseRunningException("随机点击时长少于预定时间，执行错误");            }            pullDir(deviceId, outputdir, localPullDir.toString());        }        return localPullDir.toString();    }    public static void pushFile(String deviceId, String localFile, String remoteFile) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("push");        cmd.addArgument(localFile);        cmd.addArgument(remoteFile);        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        try {            adbexe.setTimeout(INFINITE_TIMEOUT);            adbexe.exec();        } catch (IOException e) {            String error = adbexe.getError();            log.error("Push 文件夹 TO 设备错误, {}, error: {}", cmd.toString(), error);        }    }    public static void pushFile(String deviceId, String localFile, String remoteFile, String mode) {        pushFile(deviceId, localFile, remoteFile);        String ret = chmod(deviceId, remoteFile, mode);    }    public static String chmod(String deviceId, String remoteFile, String mode) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("chmod");        cmd.addArgument("-R");        cmd.addArgument(mode);        cmd.addArgument(remoteFile);        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        try {            adbexe.exec();        } catch (IOException e) {            String error = adbexe.getError();        }        return adbexe.getOutput();    }    public static void pullDir(String deviceId, String remoteDir, String localDir) {        try {            Files.createDirectories(Paths.get(localDir));        } catch (IOException e) {            log.error("创建临时文件失败, {}", localDir, e);        }        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("pull");        cmd.addArgument(remoteDir);        cmd.addArgument(localDir);        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        try {            adbexe.exec();        } catch (IOException e) {            String error = adbexe.getError();            log.error("Pull 文件夹 TO 本地 {} 错误, {}, error: {}", localDir, cmd.toString(), error);        }    }    public static void createDir(String deviceId, String remoteDir) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("mkdir");        cmd.addArgument(remoteDir);        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        try {            adbexe.exec();        } catch (IOException e) {            String error = adbexe.getError();            log.error("创建文件夹错误, {}, error: {}", cmd.toString(), error);        }    }    public static void removeDir(String deviceId, String remoteDir) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("rm");        cmd.addArgument("-r");        cmd.addArgument(remoteDir);        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        try {            adbexe.exec();        } catch (IOException e) {            String output = adbexe.getOutput();            String error = adbexe.getError();            log.error("删除文件夹错误 cmd: {}  error: {}", cmd.toString(), output + "#########" + error);        }    }    /**     *@Description: 内存使用量     *@Param: [deviceId, basePackage]     *@Return: java.lang.Integer  (KB)     *@Author: wen     *@Date: 2018/5/22     */    public static Integer ram(String deviceId, String basePackage) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("dumpsys");        cmd.addArgument("meminfo");        cmd.addArgument(basePackage);        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        Integer value = null;        try {            adbexe.exec();            String output = adbexe.getOutput();            String[] m = output.split("\\s+");            String s_mem = String.join(".", m);            String pattern = "TOTAL.(\\d+)*";            Pattern r = Pattern.compile(pattern);            Matcher matcher = r.matcher(s_mem);            if (matcher.find()) {                if( StringUtils.isNotBlank(matcher.group(1))){                    value = Integer.parseInt(matcher.group(1));                }            }        } catch (IOException e) {            String output = adbexe.getOutput();            String error = adbexe.getError();            log.error("获得内存数据错误 cmd: {}  error: {}", cmd.toString(), output + "#########" + error);        }        return value;    }    /**     *@Description: 电池占用比     *@Param: [deviceId]     *@Return: java.lang.Integer     *@Author: wen     *@Date: 2018/5/22     */    public static Integer battery(String deviceId) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("dumpsys");        cmd.addArgument("battery");        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        Integer value = null;        try {            adbexe.exec();            String output = adbexe.getOutput();            String[] m = output.split("\\s+");            String s_bat = String.join(".", m);            String pattern = "level:.(\\d+)*";            Pattern r = Pattern.compile(pattern);            Matcher matcher = r.matcher(s_bat);            if (matcher.find( )) {                if( StringUtils.isNotBlank(matcher.group(1))){                    value = Integer.parseInt(matcher.group(1));                }            }        } catch (IOException e) {            String output = adbexe.getOutput();            String error = adbexe.getError();            log.error("获得电池占用比错误 cmd: {}  error: {}", cmd.toString(), output + "#########" + error);        }        return value;    }    /**     *@Description: CPU核心数     *@Param: [deviceId, basePackage]     *@Return: java.lang.Integer     *@Author: wen     *@Date: 2018/5/22     */    public static Integer getCpuKel(String deviceId) {        Integer count = null;        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("cat");        cmd.addArgument("/proc/cpuinfo");        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        try {            adbexe.exec();            String output = adbexe.getOutput();            String[] m = output.split("\\s+");            String s_cpu = String.join(".", m);            String pattern = "processor";            Pattern r = Pattern.compile(pattern);            Matcher matcher = r.matcher(s_cpu);            int index = 0;            while (matcher.find()){ // 如果匹配,则数量+1                index++;            }            count = index;        } catch (IOException e) {            String output = adbexe.getOutput();            String error = adbexe.getError();            log.error("获得CPU核心数错误 cmd: {}  error: {}", cmd.toString(), output + "#########" + error);        }        return count;    }    /**     *@Description: CPU总耗时     *@Param: [deviceId]     *@Return: java.lang.Integer     *@Author: wen     *@Date: 2018/5/22     */    public static Integer totalCpuTime(String deviceId) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("cat");        cmd.addArgument("/proc/stat");        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        int totalTime = 0;        try {            adbexe.exec();            String output = adbexe.getOutput();            String[] lines = output.split("\n");            for (String line : lines) {                String[] cpus = line.trim().split("\\s+");                if("cpu".equals(cpus[0])){                    for(int i=1;i<cpus.length;i++){                        totalTime += Integer.parseInt(cpus[i]);                    }//                    int user = Integer.parseInt(cpus[1]);//                    int nice = Integer.parseInt(cpus[2]);//                    int system = Integer.parseInt(cpus[3]);//                    int idle = Integer.parseInt(cpus[4]);//                    int iowait = Integer.parseInt(cpus[5]);//                    int irq = Integer.parseInt(cpus[6]);//                    int softirq = Integer.parseInt(cpus[7]);//                    int stealstolen = Integer.parseInt(cpus[8]);//                    int guest = Integer.parseInt(cpus[9]);//                    int guest_nice = Integer.parseInt(cpus[10]);//                    totalTime = user + nice + system + idle + iowait + irq + softirq + stealstolen + guest + guest_nice;                }            }        } catch (IOException e) {            String output = adbexe.getOutput();            String error = adbexe.getError();            log.error("获得CPU总耗时错误 cmd: {}  error: {}", cmd.toString(), output + "#########" + error);        }        return totalTime;    }    /**     *@Description: 进程CPU耗时     *@Param: [pid, deviceId]     *@Return: java.lang.Integer     *@Author: wen     *@Date: 2018/5/22     */    public static Integer processCpuTime(String pid, String deviceId) {        Integer totalTime = null;        if (StringUtils.isNotBlank(pid)){            CommandLine cmd = getADBCommandLine(deviceId);            cmd.addArgument("shell");            cmd.addArgument("cat");            cmd.addArgument("/proc/" + pid + "/stat");            UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);            try {                adbexe.exec();                String output = adbexe.getOutput();                String[] cpus = output.trim().split("\\s+");                if(cpus.length >= 17){                    int utime = Integer.parseInt(cpus[13]);                    int stime = Integer.parseInt(cpus[14]);                    int cutime = Integer.parseInt(cpus[15]);                    int cstime = Integer.parseInt(cpus[16]);                    totalTime = utime + stime + cutime + cstime;                }else{                    log.debug(output);                }            } catch (IOException e) {                String output = adbexe.getOutput();                String error = adbexe.getError();                log.error("获得进程CPU耗时错误 cmd: {}  error: {}", cmd.toString(), output + "#########" + error);            }        }        return totalTime;    }        public static Double cpuRate(String deviceId, String pid, Integer cpukel) throws InterruptedException {        Double rate = null;        if(StringUtils.isNotBlank(pid)){            Integer ProcessCpuTime1 = processCpuTime(pid, deviceId);            Integer totalCpuTime1 = totalCpuTime(deviceId);            if(ProcessCpuTime1 == null || totalCpuTime1 == null) {                return null;            }            TimeUnit.MILLISECONDS.sleep(1);            Integer ProcessCpuTime2 = processCpuTime(pid, deviceId);            if(ProcessCpuTime2 == null) {                return null;            }            while(ProcessCpuTime2.equals(ProcessCpuTime1)){                ProcessCpuTime2 = processCpuTime(pid, deviceId);                TimeUnit.MILLISECONDS.sleep(1);            }            Integer pct = ProcessCpuTime2 - ProcessCpuTime1;            Integer totalCpuTime2 = totalCpuTime(deviceId);            if(totalCpuTime2 == null) {                return null;            }            Integer tct = (totalCpuTime2 - totalCpuTime1) * cpukel;            Double cpu = 100 * (pct * 1.0) / tct;            BigDecimal bg = new BigDecimal(cpu);            rate = bg.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();        }        return rate;    }        /**     *@Description: wifi和gprs上下行流量     *@Param: [deviceId, pid]     *@Return: com.testwa.distest.client.component.FlowResult  (bytes)     *@Author: wen     *@Date: 2018/5/22     */    public static FlowResult getFlow(String deviceId, String pid) {        FlowResult result = new FlowResult();        if(pid != null){            CommandLine cmd = getADBCommandLine(deviceId);            cmd.addArgument("shell");            cmd.addArgument("cat");            cmd.addArgument("/proc/" + pid + "/net/dev");            UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);            try {                adbexe.exec();                String output = adbexe.getOutput();                String[] lines = output.split("\n");                for (String line : lines) {                    String[] items = line.trim().split("\\s+");                    if("wlan0:".equals(items[0].trim())){                        // wifi                        if(StringUtils.isNotBlank(items[1].trim())){                            Long Flow = Long.parseLong(items[1].trim());                            result.setWifiDown(Flow/1024);                        }                        if(StringUtils.isNotBlank(items[9].trim())){                            Long Flow = Long.parseLong(items[9].trim());                            result.setWifiUp(Flow/1024);                        }                    }                    if("rmnet0:".equals(items[0].trim())) {                        // gprs                        if (StringUtils.isNotBlank(items[1].trim())) {                            Long Flow = Long.parseLong(items[1].trim());                            result.setGprsDown(Flow/1024);                        }                        if (StringUtils.isNotBlank(items[9].trim())) {                            Long Flow = Long.parseLong(items[9].trim());                            result.setGprsUp(Flow/1024);                        }                    }                }            } catch (IOException e) {                String output = adbexe.getOutput();                String error = adbexe.getError();                log.error("获取流量信息错误 cmd: {}  error: {}", cmd.toString(), output + "#########" + error);            }        }        return result;    }    /**     *@Description: 本次app打开之后消耗的流量     *@Param: [deviceId, pid]     *@Return: com.testwa.distest.client.component.FlowResult     *@Author: wen     *@Date: 2018/5/22     */    public static FlowResult[] flow(String deviceId, String pid, FlowResult lastFlow) throws InterruptedException {        FlowResult totalFlow = getFlow(deviceId, pid);        while(totalFlow.getWifiDown() - lastFlow.getWifiDown() < 0) {            TimeUnit.MILLISECONDS.sleep(1000);            lastFlow = totalFlow;            totalFlow = getFlow(deviceId, pid);        }        FlowResult result = new FlowResult();        result.setWifiDown(totalFlow.getWifiDown() - lastFlow.getWifiDown());        result.setWifiUp(totalFlow.getWifiUp() - lastFlow.getWifiUp());        result.setGprsDown(totalFlow.getGprsDown() - lastFlow.getGprsDown());        result.setGprsUp(totalFlow.getGprsUp() - lastFlow.getGprsUp());        return new FlowResult[]{totalFlow, result};    }    public static String getPid(String deviceId, String basePackage) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("ps");        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        String pid = null;        try {            adbexe.exec();            String output = adbexe.getOutput();            if(StringUtils.isNotBlank(output)){                String[] lines = output.split("\n");                for (String l : lines) {                    l = l.trim().replaceAll("\r", "");                    if(l.endsWith(basePackage)){                        String[] items = l.split("\\s+");                        pid = items[1];                    }                }            }            log.debug("pid is {}", pid);        } catch (IOException e) {            String output = adbexe.getOutput();            String error = adbexe.getError();            log.error("获得 pid 错误  cmd: {}  error: {}", cmd.toString(), output + "#########" + error);        }        return pid;    }    /**     *@Description: 获得fps 在进行分析之前，需要在设置–>开发者选项中点击GPU呈现模式分析，选择在adb shell dumpsys gfxinfo中。     *@Param: [deviceId, basePackage]     *@Return: java.lang.Integer     *@Author: wen     *@Date: 2018/5/23     */    public static Integer fps(String deviceId, String basePackage) {        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("dumpsys");        cmd.addArgument("gfxinfo");        cmd.addArgument(basePackage);        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        Integer fps = null;        try {            adbexe.exec();            String output = adbexe.getOutput();            log.debug(output);            String pattern = "(Execute\n\\s+((\\d+(\\.\\d+)?\\s+){3,4})+)";            Pattern r = Pattern.compile(pattern);            Matcher matcher = r.matcher(output);            while (matcher.find()) {                String gxfinfo = matcher.group(0);                gxfinfo = gxfinfo.replace("Execute\n", "");                if(StringUtils.isNotBlank(gxfinfo)){                    String[] lines = gxfinfo.split("\n");                    int frameCount = lines.length;                    int jankCount = 0;                    int vsyncOvertime = 0;                    Double renderTime = 0.0;                    for (String line : lines) {                        String[] timeBlock = line.trim().split("\\s+");                        for(String block : timeBlock){                            if(StringUtils.isNotBlank(block)){                                renderTime += Double.parseDouble(block);                            }                        }                        /*                        当渲染时间大于16.67，按照垂直同步机制，该帧就已经渲染超时                        那么，如果它正好是16.67的整数倍，比如66.68，则它花费了4个垂直同步脉冲，减去本身需要一个，则超时3个                        如果它不是16.67的整数倍，比如67，那么它花费的垂直同步脉冲应向上取整，即5个，减去本身需要一个，即超时4个，可直接算向下取整                        最后的计算方法思路：                        执行一次命令，总共收集到了m帧（理想情况下m=128），但是这m帧里面有些帧渲染超过了16.67毫秒，算一次jank，一旦jank，                        需要用掉额外的垂直同步脉冲。其他的就算没有超过16.67，也按一个脉冲时间来算（理想情况下，一个脉冲就可以渲染完一帧）                        所以FPS的算法可以变为：                        m / （m + 额外的垂直同步脉冲） * 60                         */                        if(renderTime > 16.67) {                            jankCount += 1;                            if(renderTime % 16.67 == 0){                                vsyncOvertime = (int) ((renderTime / 16.67) - 1);                            }else{                                vsyncOvertime = (int) (renderTime / 16.67);                            }                        }                    }                    int fps_temp = (frameCount * 60) / (frameCount + vsyncOvertime);                    if(fps == null) {                        fps = fps_temp;                    }else{                        if(fps_temp > fps){                            fps = fps_temp;                        }                    }                }            }        } catch (Exception e) {            log.warn("获得 fps 数据失败");        }        return fps;    }    public static Integer getSurfaceView(String deviceId) {        //dumpsys SurfaceFlinger --latency SurfaceView        CommandLine cmd = getADBCommandLine(deviceId);        cmd.addArgument("shell");        cmd.addArgument("SurfaceFlinger");        cmd.addArgument("--latency");        cmd.addArgument("SurfaceView");        UTF8CommonExecs adbexe = new UTF8CommonExecs(cmd);        Integer fps = null;        try {            adbexe.exec();            String output = adbexe.getOutput();            log.info(output);        }catch (Exception e) {        }        return fps;    }    public static void unlockWindow(String deviceId) {        String stdout = command(deviceId, new String[]{"dumpsys", "window", "policy"});        if(StringUtils.isNotBlank(stdout)) {            if(stdout.contains("mShowingLockscreen=true")) {                if(stdout.contains("mScreenOnEarly=false")) {                    inputCode(deviceId, KeyCode.KEYCODE_POWER);                }                inputCode(deviceId, KeyCode.KEYCODE_MENU);            }        }    }    public static void main(String[] args) {        String deviceId = "4205dccb";//        String meminfo = "Applications Memory Usage (in Kilobytes):\n" +//                "Uptime: 1450348022 Realtime: 1745417581\n" +//                "\n" +//                "** MEMINFO in pid 14054 [so.ofo.labofo] **\n" +//                "                   Pss  Private  Private  SwapPss     Heap     Heap     Heap\n" +//                "                 Total    Dirty    Clean    Dirty     Size    Alloc     Free\n" +//                "                ------   ------   ------   ------   ------   ------   ------\n" +//                "  Native Heap    15673    15556       48        0    19840    15133     4706\n" +//                "  Dalvik Heap    23874    23648        8        0    33375    20030    13345\n" +//                " Dalvik Other     3309     3280        0        1\n" +//                "        Stack     1408     1408        0        0\n" +//                "       Ashmem        4        4        0        0\n" +//                "      Gfx dev    23984    23984        0        0\n" +//                "    Other dev       20        0       20        0\n" +//                "     .so mmap     7739      300     5264      281\n" +//                "    .jar mmap       10        8        0        0\n" +//                "    .apk mmap      695      144      248        0\n" +//                "    .ttf mmap      286        0      148        0\n" +//                "    .dex mmap     9006        8     5168        0\n" +//                "    .oat mmap     6703        0     1208        0\n" +//                "    .art mmap     4924     1848      680       30\n" +//                "   Other mmap      145        4       76        2\n" +//                "   EGL mtrack    16356    16356        0        0\n" +//                "    GL mtrack     8764     8764        0        0\n" +//                "      Unknown     3390     3380        4       16\n" +//                "        TOTAL   126620    98692    12872      330    53215    35163    18051\n" +//                "\n" +//                " App Summary\n" +//                "                       Pss(KB)\n" +//                "                        ------\n" +//                "           Java Heap:    26176\n" +//                "         Native Heap:    15556\n" +//                "                Code:    12496\n" +//                "               Stack:     1408\n" +//                "            Graphics:    49104\n" +//                "       Private Other:     6824\n" +//                "              System:    15056\n" +//                "\n" +//                "               TOTAL:   126620       TOTAL SWAP PSS:      330\n" +//                "\n" +//                " Objects\n" +//                "               Views:      131         ViewRootImpl:        3\n" +//                "         AppContexts:        6           Activities:        3\n" +//                "              Assets:        5        AssetManagers:        2\n" +//                "       Local Binders:       47        Proxy Binders:       28\n" +//                "       Parcel memory:       24         Parcel count:      100\n" +//                "    Death Recipients:        2      OpenSSL Sockets:       17\n" +//                "            WebViews:        0\n" +//                "\n" +//                " SQL\n" +//                "         MEMORY_USED:      212\n" +//                "  PAGECACHE_OVERFLOW:       53          MALLOC_SIZE:       62\n" +//                "\n" +//                " DATABASES\n" +//                "      pgsz     dbsz   Lookaside(b)          cache  Dbname\n" +//                "         4       32             55       17/76/12  /data/user/0/so.ofo.labofo/databases/share.db";////        String[] m = meminfo.split("\\s+");//        String s_mem = String.join(".", m);//        String pattern = "TOTAL.(\\d+)*";//        Pattern r = Pattern.compile(pattern);//        Matcher matcher = r.matcher(s_mem);//        if (matcher.find( )) {//            System.out.println("Found value: " + matcher.group(0) );//            System.out.println("Found value: " + matcher.group(1) );//        } else {//            System.out.println("NO MATCH");//        }//        String cpuinfo = "Processor\t: AArch64 Processor rev 4 (aarch64)\n" +//                "processor\t: 0\n" +//                "BogoMIPS\t: 38.40\n" +//                "Features\t: fp asimd evtstrm aes pmull sha1 sha2 crc32\n" +//                "CPU implementer\t: 0x41\n" +//                "CPU architecture: 8\n" +//                "CPU variant\t: 0x0\n" +//                "CPU part\t: 0xd03\n" +//                "CPU revision\t: 4\n" +//                "\n" +//                "processor\t: 1\n" +//                "BogoMIPS\t: 38.40\n" +//                "Features\t: fp asimd evtstrm aes pmull sha1 sha2 crc32\n" +//                "CPU implementer\t: 0x41\n" +//                "CPU architecture: 8\n" +//                "CPU variant\t: 0x0\n" +//                "CPU part\t: 0xd03\n" +//                "CPU revision\t: 4\n" +//                "\n" +//                "processor\t: 2\n" +//                "BogoMIPS\t: 38.40\n" +//                "Features\t: fp asimd evtstrm aes pmull sha1 sha2 crc32\n" +//                "CPU implementer\t: 0x41\n" +//                "CPU architecture: 8\n" +//                "CPU variant\t: 0x0\n" +//                "CPU part\t: 0xd03\n" +//                "CPU revision\t: 4\n" +//                "\n" +//                "processor\t: 3\n" +//                "BogoMIPS\t: 38.40\n" +//                "Features\t: fp asimd evtstrm aes pmull sha1 sha2 crc32\n" +//                "CPU implementer\t: 0x41\n" +//                "CPU architecture: 8\n" +//                "CPU variant\t: 0x0\n" +//                "CPU part\t: 0xd03\n" +//                "CPU revision\t: 4\n" +//                "\n" +//                "Hardware\t: Qualcomm Technologies, Inc MSM8917\n";////        String[] m = cpuinfo.split("\\s+");//        String s_cpu = String.join(".", m);//        String pattern = "processor";//        Pattern r = Pattern.compile(pattern);//        Matcher matcher = r.matcher(s_cpu);//        int count = 0;//        while (matcher.find()){ // 如果匹配,则数量+1//            count++;//        }//        System.out.println(String.valueOf(count));        String gfxinfo = "Pipeline=FrameBuilder\n" +                "Profile data in ms:\n" +                "\n" +                "\tso.ofo.labofo/so.ofo.labofo.activities.journey.MainActivity/android.view.ViewRootImpl@d568778 (visibility=8)\n" +                "\tDraw\tPrepare\tProcess\tExecute\n" +                "\n" +                "\tso.ofo.labofo/com.ofo.login.ui.LoginByPhoneActivity/android.view.ViewRootImpl@f29e5be (visibility=0)\n" +                "\tDraw\tPrepare\tProcess\tExecute\n" +                "\t0.66\t0.10\t0.81\t5.29\n" +                "\t0.69\t0.10\t0.84\t4.44\n" +                "\t0.76\t0.11\t0.94\t4.86\n" +                "\t0.74\t0.12\t1.12\t5.15\n" +                "\t0.80\t0.11\t1.04\t5.75\n" +                "\t0.81\t0.23\t1.13\t5.05\n" +                "\t0.79\t0.12\t1.05\t5.14\n" +                "\t0.77\t0.12\t1.15\t5.82\n" +                "\t2.46\t0.17\t0.95\t4.13\n" +                "\t10.21\t0.12\t0.93\t10.84\n" +                "\t50.00\t0.13\t0.87\t4.27\n" +                "\t2.54\t0.46\t2.10\t1.77\n" +                "\t0.89\t0.21\t3.52\t2.48\n" +                "\t5.47\t0.24\t0.93\t2.54\n" +                "\t5.42\t0.23\t0.96\t2.52\n" +                "\t0.82\t2.19\t0.98\t3.48\n" +                "\t5.56\t0.21\t0.92\t2.45\n" +                "\t5.27\t1.25\t0.99\t2.42\n" +                "\t0.85\t0.26\t1.05\t3.10\n" +                "\t0.86\t0.15\t1.27\t2.84\n" +                "\t0.86\t0.17\t0.96\t3.52\n" +                "\t0.84\t0.13\t0.97\t3.15\n" +                "\t0.85\t0.28\t0.95\t2.85\n" +                "\t0.87\t0.26\t0.94\t4.91\n" +                "\t0.87\t0.30\t0.92\t2.90\n" +                "\t0.81\t0.27\t1.08\t2.48\n" +                "\t0.82\t0.13\t0.93\t2.97\n" +                "\t0.80\t0.13\t0.91\t3.83\n" +                "\t0.80\t0.27\t1.06\t2.78\n" +                "\t0.95\t0.11\t0.96\t2.76\n" +                "\t0.84\t0.26\t0.91\t2.98\n" +                "\t0.81\t0.27\t0.93\t2.60\n" +                "\t0.80\t0.14\t0.90\t2.69\n" +                "\t0.80\t0.13\t0.92\t2.82\n" +                "\t3.27\t0.23\t1.04\t2.00\n" +                "\n" +                "View hierarchy:\n" +                "\n" +                "  so.ofo.labofo/so.ofo.labofo.activities.journey.MainActivity/android.view.ViewRootImpl@d568778\n" +                "  79 views, 61.72 kB of display lists\n" +                "\n" +                "  so.ofo.labofo/com.ofo.login.ui.LoginByPhoneActivity/android.view.ViewRootImpl@f29e5be\n" +                "  48 views, 46.50 kB of display lists";//        String pattern = "(Execute\n\\s+((\\d+(\\.\\d+)?\\s+){3,4})+)";//        Pattern r = Pattern.compile(pattern);//        Matcher matcher = r.matcher(gfxinfo);//        while (matcher.find()) {//            System.out.println("Found value: " + matcher.group(0) );//            System.out.println("Found value: " + matcher.group(1) );//        }        // "so.ofo.labofo"//        Integer count = getCpuKel("b15d91f");//        System.out.println("Found value: " + count );//        String apk = "/Users/wen/Documents/Testwa/测试app和脚本/ContactManager.apk";//        installApp("b15d91f", apk);//        launcherApp("b15d91f", apk);//        launcherApp("5SIFFE95HEQ8YDOB", "/Users/wen/Downloads/me.ele-7.40.1-257.apk");//        Runtime runtime = Runtime.getRuntime();//        try {//            Process pid = runtime.exec(AndroidSdk.adb().toString() + " shell dumpsys package | grep -i me.ele | grep Activity");//            BufferedReader stdoutReader = new BufferedReader(new InputStreamReader(pid.getInputStream(), StandardCharsets.UTF_8));//            BufferedReader stderrReader = new BufferedReader(new InputStreamReader(pid.getErrorStream(), StandardCharsets.UTF_8));//            String line;//            while ((line = stdoutReader.readLine()) != null) {//                log.info(line);//            }//            System.out.println("ERROR");//            while ((line = stderrReader.readLine()) != null) {//                log.error(line);//            }//            int exitVal = pid.waitFor();//            System.out.println("pid exit value is " + exitVal);//        } catch (IOException e) {//            e.printStackTrace();//        } catch (InterruptedException e) {//            e.printStackTrace();//        }//        System.out.println(getAbi("8c2b6aee"));//        unlockWindow("8c2b6aee");        String basePackage = "com.netease.cloudmusic";        String pid = getPid(deviceId, basePackage);        Integer fps = getSurfaceView(deviceId);        log.info("fps ==== {}", fps);    }}