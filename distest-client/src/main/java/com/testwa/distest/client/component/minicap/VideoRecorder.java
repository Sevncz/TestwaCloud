package com.testwa.distest.client.component.minicap;import com.testwa.distest.client.android.PhysicalSize;import lombok.extern.slf4j.Slf4j;import org.bytedeco.javacpp.BytePointer;import org.bytedeco.javacpp.avcodec;import org.bytedeco.javacpp.avutil;import org.bytedeco.javacpp.opencv_core;import org.bytedeco.javacv.FFmpegFrameRecorder;import org.bytedeco.javacv.Frame;import org.bytedeco.javacv.FrameRecorder;import org.bytedeco.javacv.OpenCVFrameConverter;import java.io.Closeable;import java.io.IOException;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;import static org.bytedeco.javacpp.opencv_core.CV_8UC1;import static org.bytedeco.javacpp.opencv_core.cvMat;import static org.bytedeco.javacpp.opencv_core.cvReleaseImage;import static org.bytedeco.javacpp.opencv_imgcodecs.cvDecodeImage;/** * @Program: distest * @Description: * @Author: wen * @Create: 2018-07-05 11:35 **/@Slf4jpublic class VideoRecorder extends Thread implements Closeable {    private FFmpegFrameRecorder recorder;    private static final int FRAME_RATE = 25;    private static final int MOTION_FACTOR = 1;    private static final int QUEUE_SIZE = 100;    private BlockingQueue<byte[]> frameQueue;    private PhysicalSize size;    private float zoom = 0.3f;    private String outputFile;    private String formate;    private int videoCodec;//    private byte[] lastFrame;    boolean recording = false;    /** 是否运行 */    private AtomicBoolean isRunning = new AtomicBoolean(false);    /** 是否重启 */    private AtomicBoolean restart = new AtomicBoolean(false);    /**     * 屏幕尺寸     * @param size     */    public void setSize(PhysicalSize size) {        this.size = size;    }    public void setZoom(float zoom) {        this.zoom = zoom;    }    /**     * 输出文件     * @param outputFile     */    public void setOutputFile(String outputFile) {        this.outputFile = outputFile;    }    /**     * 编/解码器     * @param     */    public void setHEVC() {        this.videoCodec = avcodec.AV_CODEC_ID_HEVC;        this.formate = "mp4";    }    public void setH264() {        this.videoCodec = avcodec.AV_CODEC_ID_H264;        this.formate = "flv";    }    @Override    public void close() throws IOException {        if(recorder != null && recording) {            recording = false;            recorder.stop();            recorder.release();        }        recorder = null;        isRunning.set(false);        restart.set(false);    }    /**     * 重启     */    public synchronized void restart() throws FrameRecorder.Exception {        if(recorder != null) {            recorder.stop();            recorder.release();        }        restart.set(true);    }    @Override    public synchronized void start() {        if (this.isRunning.get()) {            throw new IllegalStateException("VideoRecorder服务已运行");        } else {            this.isRunning.set(true);        }        frameQueue = new LinkedBlockingQueue<>(QUEUE_SIZE);        super.start();    }    public void run() {        initRecorder();        try {            recorder.start();            recording = true;        } catch (FrameRecorder.Exception e) {//            if (recorder != null) {//                log.error("recorder start error!", e);//                try {//                    recorder.stop();//                    recorder.start();//                } catch (FrameRecorder.Exception e1) {//                    e1.printStackTrace();//                    this.restart.set(true);//                }//            }            log.warn("视频录制错误", e);        }        OpenCVFrameConverter.ToIplImage conveter = new OpenCVFrameConverter.ToIplImage();        while(recording && this.isRunning.get()) {            try {                byte[] data = frameQueue.poll(20, TimeUnit.MILLISECONDS);                if(data != null) {                    opencv_core.IplImage image = cvDecodeImage(cvMat(1, data.length, CV_8UC1, new BytePointer(data)));                    encodeFrame(conveter.convert(image), System.currentTimeMillis());                    cvReleaseImage(image);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private void encodeFrame(Frame frame, long timestamp) {                if(recorder != null) {                    try {//                        if (timestamp > recorder.getTimestamp()) {//                            recorder.setTimestamp(timestamp);//                        }                        recorder.record(frame);                    } catch (Exception e) {                        log.warn("abort {} {}", e.getMessage(), e.getCause());                    }                }//                    this.lastFrame = data;//                else{//                    if(this.lastFrame != null) {//                        opencv_core.IplImage image = cvDecodeImage(cvMat(1, this.lastFrame.length, CV_8UC1, new BytePointer(this.lastFrame)));//                        if(recorder != null) {//                            try {//                                recorder.record(conveter.convert(image));//                                cvReleaseImage(image);//                            } catch (Exception e1) {//                                log.warn("abort1 {} {}", e1.getMessage(), e1.getCause());//                            }//                        }//                    }//                }    }    /**     * @Description: initialize ffmpeg_recorder     * @Param: []     * @Return: void     * @Author wen     * @Date 2018/9/3 15:29     */    private void initRecorder() {        int h = (int) (this.size.getHeight() * zoom);        int w = (int) (this.size.getWidth() * zoom);        int m_dst_h = (h >> 4) << 4;        int m_dst_w = (w >> 4) << 4;        this.recorder = new FFmpegFrameRecorder(outputFile, m_dst_w, m_dst_h, 1);//        this.recorder.setInterleaved(true);        /**         * 该参数用于降低延迟 参考FFMPEG官方文档：https://trac.ffmpeg.org/wiki/StreamingGuide         * 官方原文参考：ffmpeg -f dshow -i video="Virtual-Camera" -vcodec libx264         * -tune zerolatency -b 900k -f mpegts udp://10.1.0.102:1234         *///        recorder.setVideoOption("tune", "zerolatency");        /**         * 权衡quality(视频质量)和encode speed(编码速度) values(值)：         * ultrafast(终极快),superfast(超级快), veryfast(非常快), faster(很快), fast(快),         * medium(中等), slow(慢), slower(很慢), veryslow(非常慢)         * ultrafast(终极快)提供最少的压缩（低编码器CPU）和最大的视频流大小；而veryslow(非常慢)提供最佳的压缩（高编码器CPU）的同时降低视频流的大小         * 参考：https://trac.ffmpeg.org/wiki/Encode/H.264 官方原文参考：-preset ultrafast         * as the name implies provides for the fastest possible encoding. If         * some tradeoff between quality and encode speed, go for the speed.         * This might be needed if you are going to be transcoding multiple         * streams on one machine.         *///        recorder.setVideoOption("preset", "ultrafast");        /**         * 参考转流命令: ffmpeg         * -i'udp://localhost:5000?fifo_size=1000000&overrun_nonfatal=1' -crf 30         * -preset ultrafast -acodec aac -strict experimental -ar 44100 -ac         * 2-b:a 96k -vcodec libx264 -r 25 -b:v 500k -f flv 'rtmp://<wowza         * serverIP>/live/cam0' -crf 30         * -设置内容速率因子,这是一个x264的动态比特率参数，它能够在复杂场景下(使用不同比特率，即可变比特率)保持视频质量；         * 可以设置更低的质量(quality)和比特率(bit rate),参考Encode/H.264 -preset ultrafast         * -参考上面preset参数，与视频压缩率(视频大小)和速度有关,需要根据情况平衡两大点：压缩率(视频大小)，编/解码速度 -acodec         * aac -设置音频编/解码器 (内部AAC编码) -strict experimental         * -允许使用一些实验的编解码器(比如上面的内部AAC属于实验编解码器) -ar 44100 设置音频采样率(audio sample         * rate) -ac 2 指定双通道音频(即立体声) -b:a 96k 设置音频比特率(bit rate) -vcodec libx264         * 设置视频编解码器(codec) -r 25 -设置帧率(frame rate) -b:v 500k -设置视频比特率(bit         * rate),比特率越高视频越清晰,视频体积也会变大,需要根据实际选择合理范围 -f flv         * -提供输出流封装格式(rtmp协议只支持flv封装格式) 'rtmp://<FMS server         * IP>/live/cam0'-流媒体服务器地址         *///        recorder.setVideoOption("crf","28");        recorder.setVideoBitrate((int)((m_dst_w*m_dst_h*FRAME_RATE)*MOTION_FACTOR*0.07));        // 编/解码器        recorder.setVideoCodec(this.videoCodec);        // 封装格式        recorder.setPixelFormat(avutil.AV_PIX_FMT_YUV420P);//        recorder.setPixelFormat(avutil.AV_PIX_FMT_NV21);        recorder.setFormat(this.formate);        recorder.setVideoQuality(0); // lossless        // 视频帧率(保证视频质量的情况下最低25，低于25会出现闪屏)        recorder.setFrameRate(FRAME_RATE);    }    public void offer(byte[] data) {        frameQueue.offer(data);    }}