package com.testwa.distest.client.control.client;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.github.cosysoft.device.android.AndroidDevice;import com.github.cosysoft.device.android.impl.AndroidDeviceStore;import com.github.cosysoft.device.android.impl.DefaultAndroidApp;import com.google.protobuf.ByteString;import com.testwa.core.cmd.AppInfo;import com.testwa.core.cmd.RemoteRunCommand;import com.testwa.core.common.enums.Command;import com.testwa.distest.client.android.AndroidHelper;import com.testwa.distest.client.component.Constant;import com.testwa.distest.client.component.appium.utils.Config;import com.testwa.distest.client.component.executor.DeviceTask;import com.testwa.distest.client.component.executor.DeviceTaskListener;import com.testwa.distest.client.component.logcat.Logcat;import com.testwa.distest.client.component.logcat.LogcatListener;import com.testwa.distest.client.component.minicap.Banner;import com.testwa.distest.client.component.minicap.Minicap;import com.testwa.distest.client.component.minicap.MinicapListener;import com.testwa.distest.client.component.minitouch.Minitouch;import com.testwa.distest.client.component.minitouch.MinitouchListener;import com.testwa.distest.client.control.client.callback.DefaultObserver;import com.testwa.distest.client.download.Downloader;import com.testwa.distest.client.exception.DownloadFailException;import com.testwa.distest.client.grpc.Gvice;import io.grpc.Channel;import io.rpc.testwa.device.ScreenCaptureRequest;import io.rpc.testwa.push.ClientInfo;import io.rpc.testwa.push.PushGrpc;import io.rpc.testwa.push.Status;import io.rpc.testwa.push.TopicInfo;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * @Program: distest * @Description: * @Author: wen * @Create: 2018-05-08 16:27 **/@Slf4jpublic class DeviceClient implements MinicapListener, MinitouchListener, DeviceTaskListener, LogcatListener {    private final PushGrpc.PushStub asyncStub;    private final PushGrpc.PushBlockingStub blockingStub;    private final Channel channel;    private final String clientId;    private final String userToken;    private final ClientInfo clientInfo;    static final int DATA_TIMEOUT = 100; //ms    private boolean isWaitting = false;    private boolean isLogcatWaitting = false;    private BlockingQueue<ImageData> dataQueue = new LinkedBlockingQueue<>();    private BlockingQueue<ImageData> toVideoDataQueue = new LinkedBlockingQueue<>();    private String resourcesPath;  // minicap和minitouch存放的路径    private Minicap minicap = null;    private Minitouch minitouch = null;    private DeviceTask task = null;    private Logcat logcat = null;    private String minicapCommand;    private boolean isVideo;    public DeviceClient(String deviceId, Channel channel, String resourcesPath, String userToken){        this.clientId = deviceId;        this.userToken = userToken;        this.clientInfo = ClientInfo.newBuilder().setDeviceId(clientId).setToken(userToken).build();        this.channel = channel;        this.asyncStub = PushGrpc.newStub(channel);        this.blockingStub = PushGrpc.newBlockingStub(channel);        this.resourcesPath = resourcesPath;        log.info("init client "+ clientId);        // install 支持中文输入的输入法        String keyboardPath = this.resourcesPath + File.separator + Constant.getKeyboardService();        try {            if(Files.exists(Paths.get(keyboardPath))){                AndroidHelper.getInstance().installApp(keyboardPath, deviceId);            }else{                log.error("安装文件不存在");            }        }catch (Exception e){            log.error("安装中文输入失败, {}", keyboardPath);        }    }    /**     * grpc start     */    public void registerToServer(){        this.asyncStub.registerToServer(this.clientInfo, new DefaultObserver(this.clientId, this));    }    public String subscribe(String topic){        TopicInfo topicInfo = TopicInfo.newBuilder().setTopicName(topic).setClientInfo(this.clientInfo).build();        Status status = this.blockingStub.subscribe(topicInfo);        return status.getStatus();    }    public String cancel(String topic){        TopicInfo topicInfo = TopicInfo.newBuilder().setTopicName(topic).setClientInfo(this.clientInfo).build();        Status status = this.blockingStub.cancel(topicInfo);        return status.getStatus();    }    public String logoutFromServer(){        Status status = this.blockingStub.logoutFromServer(this.clientInfo);        return status.getStatus();    }    public String getClientId() {        return clientId;    }    public void stop() {        // 关闭组件        if (minitouch != null) {            minitouch.kill();        }        if (minicap != null) {            minicap.kill();        }        if (task != null) {            task.kill();        }        // 关闭录制        isVideo = false;    }    public void restart() {        // 关闭组件        if (minitouch != null) {            minitouch.kill();        }        if (minicap != null) {            minicap.kill();        }        if(StringUtils.isNotBlank(minicapCommand)){            startMinicap(minicapCommand);            startMinitouch();        }    }    /**     * ImageData start     */    public static class ImageData {        ImageData(byte[] d) {            timesp = System.currentTimeMillis();            data = d;        }        long timesp;        byte[] data;    }    /**     * minicap start     */    @Override    public void onStartup(Minicap minicap, boolean success) {    }    @Override    public void onClose(Minicap minicap) {    }    @Override    public void onBanner(Minicap minicap, Banner banner) {    }    @Override    public void onJPG(Minicap minicap, byte[] data) {        // for video queue//        toVideoDataQueue.add(new LocalClient.ImageData(data));        // for pic queue        if (isWaitting) {            if (dataQueue.size() > 0) {                dataQueue.add(new ImageData(data));                // 挑选没有超时的图片                ImageData d = getUsefulImage();                sendImage(d.data);            } else {                sendImage(data);            }//            isWaitting = false;        } else {            clearObsoleteImage();            dataQueue.add(new ImageData(data));        }    }    private void sendImage(byte[] data) {        log.debug(String.valueOf(data.length));        try {            ScreenCaptureRequest request = ScreenCaptureRequest.newBuilder()                    .setImg(ByteString.copyFrom(data))                    .setName("xxx")                    .setSerial(this.clientId)                    .build();            Gvice.deviceService(this.channel).screen(request);        }catch (Exception e){            log.error(e.getMessage());        }finally {        }    }    private ImageData getUsefulImage() {        long curTS = System.currentTimeMillis();        // 挑选没有超时的图片        ImageData d = null;        while (true) {            d = dataQueue.poll();            // 如果没有超时，或者超时了但是最后一张图片，也发送给客户端            if (d == null || curTS - d.timesp < DATA_TIMEOUT || dataQueue.size() == 0) {                break;            }        }        return d;    }    private void clearObsoleteImage() {        ImageData d = dataQueue.peek();        long curTS = System.currentTimeMillis();        while (d != null) {            if (curTS - d.timesp > DATA_TIMEOUT) {                dataQueue.poll();                d = dataQueue.peek();            } else {                break;            }        }    }    public void setWaitting(boolean waitting) {        isWaitting = waitting;        trySendImage();    }    private void trySendImage() {        ImageData d = getUsefulImage();        if (d != null) {            sendImage(d.data);        }    }    /**     * minitouch start     */    @Override    public void onStartup(Minitouch minitouch, boolean success) {    }    @Override    public void onClose(Minitouch minitouch) {    }    /**     * task start     */    @Override    public void onStartup(DeviceTask task, boolean success) {    }    @Override    public void onComplete(DeviceTask task) {    }    @Override    public void onCancel(DeviceTask task) {    }    /**     * logcat start     */    @Override    public void onStartup(Logcat logcat, boolean success) {    }    @Override    public void onClose(Logcat logcat) {    }    @Override    public void onLog(Logcat logcat, byte[] data) {    }    public void startMinicap(String command) {        log.debug("启动 minicap {}", command);        minicapCommand = command;        if (minicap == null) {            // 获取请求的配置            JSONObject obj = JSON.parseObject(command);            Float scale = obj.getFloat("scale");            Float rotate = obj.getFloat("rotate");//        scale = 0.5f;            if (scale == null) {scale = 0.3f;}            if (scale < 0.01) {scale = 0.01f;}            if (scale > 1.0) {scale = 1.0f;}            if (rotate == null) { rotate = 0.0f; }            Minicap minicap = new Minicap(clientId, resourcesPath);            minicap.addEventListener(this);            minicap.start(scale, rotate.intValue());            this.minicap = minicap;        }    }    public void startMinitouch() {        log.info("启动 minitouch");        if (minitouch == null) {            Minitouch minitouch = new Minitouch(clientId, resourcesPath);            minitouch.addEventListener(this);            minitouch.start();            this.minitouch = minitouch;        }    }    public void stopMinicap() {        if (minicap != null) {            minicap.kill();        }    }    public void stopMinitouch() {        if (minitouch != null) {            minitouch.kill();        }    }    public void keyevent(String command) {        int k = Integer.parseInt(command);        if (minitouch != null) minitouch.sendKeyEvent(k);    }    public void touch( String command) {        if (minitouch != null) minitouch.sendEvent(command);    }    public void input(String command) {        if (minitouch != null) minitouch.inputText(command);    }    /**     * 等待时，关闭logcat     * @param     */    public void stopLogcat() {        if(this.logcat != null){            this.logcat.close();        }    }    /**     * 再次发送命令下来时，重新打开logcat     * @param command     */    public void startLogcat(String command) {        if(this.logcat != null){            this.logcat.close();        }        this.isLogcatWaitting = true;        Logcat l = new Logcat(this.clientId, command);        l.addEventListener(this);        l.start();        this.logcat = l;    }    /**     *@Description: 开始执行测试任务     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void startTask(String command) {        log.info("设备 {}，开始任务 {}", clientId, command);        if (task != null) {            task.kill();        }        RemoteRunCommand cmd = JSON.parseObject(command, RemoteRunCommand.class);        DeviceTask task = new DeviceTask(cmd);        task.addEventListener(this);        task.start();        this.task = task;    }    /**     *@Description: 取消在该设备正在执行的任务     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void cancelTask() {        task.kill();    }    /**     *@Description: 安装app     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void installApp(String command) {        Thread t = new Thread(new InstallRunner(command));        t.start();    }    private class InstallRunner implements Runnable{        private String cmdJson;        public InstallRunner(String cmdJson) {            this.cmdJson = cmdJson;        }        @Override        public void run() {            AppInfo appInfo = JSON.parseObject(cmdJson, AppInfo.class);            AndroidDevice device = AndroidDeviceStore.getInstance().getDeviceBySerial(clientId);            String distestApiWeb = Config.getString("distest.api.web");            String appUrl = String.format("http://%s/app/%s", distestApiWeb, appInfo.getPath());            String appLocalPath = Constant.localAppPath + File.separator + appInfo.getMd5() + File.separator + appInfo.getFileName();            // 检查是否有和该app md5一致的            try {                Downloader d = new Downloader();                d.start(appUrl, appLocalPath);            } catch (DownloadFailException e) {                e.printStackTrace();            } catch (IOException e) {                e.printStackTrace();            }            DefaultAndroidApp androidApp = new DefaultAndroidApp(new File(appLocalPath));            device.install(androidApp);        }    }    /**     *@Description: 卸载App     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void uninstallApp(String command) {        AndroidDevice device = AndroidDeviceStore.getInstance().getDeviceBySerial(clientId);        device.uninstall(command);    }    /**     *@Description: 执行并返回shell命令的结果     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/4/10     */    public void shellCommand(String command) {        AndroidDevice device = AndroidDeviceStore.getInstance().getDeviceBySerial(clientId);        String result = device.runAdbCommand("shell " + command);        log.info(result);    }    /**     *@Description: 使用浏览器打开网页     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/5/2     */    public void openWeb(String command) {        String cmd = "shell am start -a android.intent.action.VIEW -d ";        AndroidDevice device = AndroidDeviceStore.getInstance().getDeviceBySerial(clientId);        String result = device.runAdbCommand(cmd + command);        log.info(result);    }}