package com.testwa.distest.client.component.stfservice;import com.android.ddmlib.AdbCommandRejectedException;import com.android.ddmlib.IDevice;import com.android.ddmlib.TimeoutException;import com.github.cosysoft.device.android.AndroidDevice;import com.github.cosysoft.device.exception.DeviceNotFoundException;import com.github.cosysoft.device.shell.AndroidSdk;import com.testwa.distest.client.android.AdbForward;import com.testwa.distest.client.android.AndroidHelper;import com.testwa.distest.client.control.port.ApkPortProvider;import jp.co.cyberagent.stf.proto.Wire;import lombok.Data;import lombok.extern.slf4j.Slf4j;import org.openqa.selenium.os.CommandLine;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.util.ArrayList;import java.util.List;@Data@Slf4jpublic class StfAgent {    private List<StfAgentListener> listenerList = new ArrayList<>();    private static final String STRING_ERROR = "Not found";    private static final String SERVICE_NAME = "jp.co.cyberagent.stf";    private static final String AGENT_MAIN = "jp.co.cyberagent.stf.Agent";    private static final String COMMAND_COMPONENT_SERVICE = "am startservice --user 0 -n jp.co.cyberagent.stf/.Service -a %s";    private static final String COMMAND_START_SERVICE = "jp.co.cyberagent.stf.ACTION_START";    private static final String COMMAND_STOP_SERVICE = "jp.co.cyberagent.stf.ACTION_STOP";    private static final String COMMAND_APK_PATH = "pm path jp.co.cyberagent.stf | tr -d '\\r'";    private static final String COMMAND_START_AGENT = "export CLASSPATH=\"%s\"; exec app_process /system/bin %s";    private static final String PATH_SERVICE_APK = "STFService" + File.separator + "STFService.apk";    private int mPort;    private AndroidDevice device;    private Socket mSocket;    private String resourcesPath;    private AdbForward forward;    private Thread stfAgentInitialThread;    private OutputStream mSocketOutput;    private InputStream mSocketInput;    private CommandLine commandLine;    public StfAgent(String serialNumber, String resourcesPath) {        this.resourcesPath = resourcesPath;        this.device = AndroidHelper.getInstance().getAndroidDevice(serialNumber);    }    public void start() {        int install = 5;        while (install > 0) {            try {                startService();                startForward();                startAgent();                connect();                Thread.sleep(1000);                break;            } catch (StfServiceInstallException | DeviceNotFoundException e) {                log.error(e.getMessage());                install--;            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private void startService() throws StfServiceInstallException {        String command = String.format(COMMAND_COMPONENT_SERVICE, COMMAND_START_SERVICE);        log.info("stfservice start command {}", command);        String result = AndroidHelper.getInstance().executeShellCommand(device.getDevice(), command);        if (result == null) {            throw new StfServiceInstallException("stfagent service start error, command result is null");        }        // apk没有安装，重新安装        if (result.contains(STRING_ERROR)) {            installService();            result =  AndroidHelper.executeCommand(device.getDevice(), command);            if (result.contains(STRING_ERROR)) {                throw new StfServiceInstallException("stfagent service start error, command result is" + result);            }        }    }    private void installService() {        String apkFile = resourcesPath + File.separator + PATH_SERVICE_APK;        AndroidHelper.getInstance().installApp(apkFile, device.getSerialNumber());    }    private void startForward() {        this.forward = createForward();        log.info("stfagent forward port {}", forward.getPort());    }    public AdbForward createForward() {        AdbForward forward = generateForwardInfo();        // 修复 com.github.cosysoft.device.shell.ShellCommandException: error: device unauthorized.        int tryTime = 10;        while(tryTime >= 0){            try {                device.getDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);                return forward;            } catch (Exception e) {                log.error("create forward failed", e);                tryTime--;                try {                    Thread.sleep(500);                } catch (InterruptedException e1) {                    e1.printStackTrace();                }            }        }        return null;    }    /**     * 生成forward信息     */    private AdbForward generateForwardInfo() {        AdbForward[] forwards = AndroidHelper.getInstance().getForwardList();        // serial_touch_number        int maxNumber = 0;        if (forwards.length > 0) {            for (AdbForward forward : forwards) {                if (forward.getSerialNumber().equals(device.getSerialNumber())) {                    String l = forward.getLocalabstract();                    String[] s = l.split("_");                    if (s.length == 3) {                        int n = Integer.parseInt(s[2]);                        if (n > maxNumber) maxNumber = n;                    }                }            }        }        maxNumber += 1;        String forwardStr = String.format("%s_stfagent_%d", device.getSerialNumber(), maxNumber);        int freePort = ApkPortProvider.pullPort();        AdbForward forward = new AdbForward(device.getSerialNumber(), freePort, forwardStr);        return forward;    }    private void startAgent() {        String pathResult = AndroidHelper.getInstance().executeShellCommand(device.getDevice(), COMMAND_APK_PATH);        // pathResult is package:/data/app/jp.co.cyberagent.stf-1.apk        String path = pathResult.replace("package:", "").trim();        log.info("stfagent path, {}", path);        String command = String.format(COMMAND_START_AGENT, path, AGENT_MAIN);        log.info("stfagent start cmd, {}", command);        try {            commandLine = new CommandLine(AndroidSdk.adb().getCanonicalPath(),                    "-s",                    device.getSerialNumber(),                    "shell",                    command                    );            commandLine.executeAsync();        } catch (IOException e) {            e.printStackTrace();        }    }    private void connect() {        stfAgentInitialThread = new Thread(new StartInitial("127.0.0.1", forward.getPort()));        stfAgentInitialThread.start();    }    class StartInitial implements Runnable {        private String host;        private int port;        public StartInitial(String host, int port) {            this.host = host;            this.port = port;        }        public void run() {            int tryTime = 20;            // 连接stfservice启动的服务            while (true) {                try {                    Thread.sleep(1000);                    log.info("commandLine {}", commandLine.isRunning());                    mSocket = new Socket(host, port);                    mSocketInput = mSocket.getInputStream();                    mSocketOutput = mSocket.getOutputStream();                    log.info("stfservice ---------- start, on {} ", port);                    onStartup(true);                    break;                } catch (Exception ex) {                    log.error("stfservice connect error, {}, {}", this.host, this.port, ex);                    if (mSocket != null) {                        try {                            mSocket.close();                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                }                tryTime--;                if (tryTime == 0) {                    onStartup(false);                    break;                }            }        }    }    public void backEvent() {        onKeyEvent(KeyCode.KEYCODE_BACK);    }    public void menuEvent() {        onKeyEvent(KeyCode.KEYCODE_MENU);    }    public void homeEvent() {        onKeyEvent(KeyCode.KEYCODE_HOME);    }    public void onKeyEvent(int keyCode) {        Wire.KeyEventRequest.Builder builder = Wire.KeyEventRequest.newBuilder();        builder.setKeyCode(keyCode);        builder.setEvent(Wire.KeyEvent.DOWN);        Wire.KeyEventRequest request = builder.build();        Wire.Envelope.Builder envBuild = Wire.Envelope.newBuilder();        envBuild.setType(Wire.MessageType.DO_KEYEVENT);        envBuild.setMessage(request.toByteString());        Wire.Envelope envelope = envBuild.build();        executeKeyEvent(envelope);        Wire.KeyEventRequest.Builder builder2 = Wire.KeyEventRequest.newBuilder();        builder2.setKeyCode(keyCode);        builder2.setEvent(Wire.KeyEvent.UP);        Wire.Envelope.Builder envBuild2 = Wire.Envelope.newBuilder();        envBuild2.setType(Wire.MessageType.DO_KEYEVENT);        envBuild2.setMessage(builder2.build().toByteString());        executeKeyEvent(envBuild2.build());    }    private void removeForward(AdbForward forward) {        if (forward == null || !forward.isForward()) {            return;        }        try {            device.getDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);        } catch (AdbCommandRejectedException e) {            log.info("removeForward: AdbCommandRejectedException, {}", e.getMessage());        } catch (IOException e) {            log.error("removeForward: IOException, {}", e.getMessage());        } catch (TimeoutException e) {            log.error("removeForward: TimeoutException, {}", e.getMessage());        }    }    private void executeKeyEvent(Wire.Envelope input) {        if (mSocketInput == null) {            return;        }        try {            input.writeDelimitedTo(mSocketOutput);            mSocketOutput.flush();        } catch (IOException e) {            e.printStackTrace();        }    }    public void kill() {        onClose();        // 关闭socket        if (mSocket != null && mSocket.isConnected()) {            try {                mSocket.close();            } catch (IOException e) {            }            mSocket = null;        }    }    public void addEventListener(StfAgentListener listener) {        if (listener != null) {            this.listenerList.add(listener);        }    }    private void onStartup(boolean success) {        for (StfAgentListener listener : listenerList) {            listener.onStartup(this, success);        }    }    private void onClose() {        for (StfAgentListener listener : listenerList) {            listener.onClose(this);        }        removeForward(forward);    }}