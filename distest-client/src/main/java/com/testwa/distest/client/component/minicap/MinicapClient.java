package com.testwa.distest.client.component.minicap;import lombok.extern.slf4j.Slf4j;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.ArrayUtils;import java.io.Closeable;import java.io.IOException;import java.io.InputStream;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicBoolean;/** * @Program: distest * @Description: 获得 minicap 的数据并发送 * @Author: wen * @Create: 2018-06-20 11:58 **/@Slf4jpublic class MinicapClient extends Thread implements Closeable {    private String host = "127.0.0.1";    private int port;    private Socket socket;    /** 队列大小 */    private int queueSize = 50;    /** 调用take的线程 */    private Thread takeThread;    /** 存放图片队列 */    private BlockingQueue<byte[]> frameQueue;    /** Banner */    private Banner banner;    /** 已读取Banner的长度 */    private int readBannerBytes = 0;    /** Banner的长度 */    private int bannerLength = 2;    /** 已读取帧的长度 */    private int readFrameBytes = 0;    /** 帧的长度 */    private int frameBodyLength = 0;//    private byte[] frameBody = new byte[0];//    private int total;    /** 上一帧*/    private byte[] lastFrame;    private int allowFrame = 0;    /** 视频录制器*/    private VideoRecorder recorder;    /** 是否运行 */    private AtomicBoolean isRunning = new AtomicBoolean(false);    public MinicapClient(int port) {        super("minicap-client");        this.port = port;        init();    }    public MinicapClient(String host, int port) {        super("minicap-client");        this.host = host;        this.port = port;        init();    }    public MinicapClient(int port, VideoRecorder recorder) {        super("minicap-client");        this.port = port;        this.recorder = recorder;        init();    }    /**     * 获取帧，如果没有则阻塞     * @return 帧     * @throws InterruptedException 阻塞中断     */    public synchronized byte[] take() throws InterruptedException {        checkClosed();        takeThread = Thread.currentThread();        return frameQueue.take();    }    /**     * 是否运行     * @return true 已运行 false 未运行     */    public boolean isRunning() {        return this.isRunning.get();    }    @Override    public void close() throws IOException {        this.isRunning.set(false);        IOUtils.closeQuietly(this.socket);        IOUtils.closeQuietly(this.recorder);        this.interrupt();    }    @Override    public synchronized void start() {        if (this.isRunning.get()) {            throw new IllegalStateException("Minicap 客户端已运行");        } else {            this.isRunning.set(true);        }        super.start();    }    @Override    public void run() {        // 连接minicap服务        log.info("Minicap 客户端启动中......");        InputStream inputStream = null;        this.socket = new Socket();        SocketAddress remoteAddr = new InetSocketAddress(host, port);        try {            this.socket.connect(remoteAddr,60000);            this.socket.setSoTimeout(10*1000);            inputStream = socket.getInputStream();        } catch (IOException e) {            log.error("与Minicap服务端连接失败", e);        }        log.info("与Minicap服务端连接成功");        int len = 1024 * 4;        while (isRunning.get()) {            try {                reset();                byte[] buffer;                buffer = new byte[len];                int realLen = inputStream.read(buffer);                if (buffer.length != realLen) {                    buffer = ArrayUtils.subarray(buffer, 0, realLen);                }                if(buffer.length == 0) {                    this.socket = new Socket();                    this.socket.connect(remoteAddr,60000);                    this.socket.setSoTimeout(10*1000);                    inputStream = socket.getInputStream();                }                handleServerResponse(buffer);            } catch (Exception e) {                log.warn("Minicap客户端运行错误 {}", e.getMessage());            }        }        IOUtils.closeQuietly(this.socket);    }    /**     * 处理服务端响应     */    protected void handleServerResponse(byte[] buffer) throws IOException {        // 帧        byte[] frameBody = new byte[0];        // 缓存        byte[] chunk = new byte[1024*100];        // 读取的长度        int len = buffer.length;        for (int cursor = 0; cursor < len;) {            int data = chunk[cursor] & 0xff;            if (readBannerBytes < bannerLength) {                // 读取Banner                parseBanner(data);                cursor ++;            } else if (readFrameBytes < 4) {                // 读取帧的长度                frameBodyLength += (data << (readFrameBytes * 8));                cursor ++;                readFrameBytes ++;            } else {                // 读取帧                if (len - cursor >= frameBodyLength) {                    byte[] subByte = ArrayUtils.subarray(chunk, cursor, cursor + frameBodyLength);                    frameBody = ArrayUtils.addAll(frameBody, subByte);                    // 获取到一帧                    offer(frameBody);                    cursor += frameBodyLength;                    frameBodyLength = readFrameBytes = 0;                    frameBody = new byte[0];                } else {                    byte[] subByte = ArrayUtils.subarray(chunk, cursor, len);                    frameBody = ArrayUtils.addAll(frameBody, subByte);                    frameBodyLength -= len - cursor;                    readFrameBytes += len - cursor;                    cursor = len;                }            }        }    }    /**     * 解析Banner     */    protected void parseBanner(int data) {        if (banner == null) {            banner = new Banner();        }        switch (readBannerBytes) {            case 0:                // version                banner.setVersion(data);                break;            case 1:                // length                banner.setLength(bannerLength = data);                break;            case 2:            case 3:            case 4:            case 5:                // pid                int pid = banner.getPid();                pid += (data << ((readBannerBytes - 2) * 8));                banner.setPid(pid);                break;            case 6:            case 7:            case 8:            case 9:                // real width                int realWidth = banner.getRealWidth();                realWidth += (data << ((readBannerBytes - 6) * 8));                banner.setRealWidth(realWidth);                break;            case 10:            case 11:            case 12:            case 13:                // real height                int realHeight = banner.getRealHeight();                realHeight += (data << ((readBannerBytes - 10) * 8));                banner.setRealHeight(realHeight);                break;            case 14:            case 15:            case 16:            case 17:                // virtual width                int virtualWidth = banner.getVirtualWidth();                virtualWidth += (data << ((readBannerBytes - 14) * 8));                banner.setVirtualWidth(virtualWidth);                break;            case 18:            case 19:            case 20:            case 21:                // virtual height                int virtualHeight = banner.getVirtualHeight();                virtualHeight += (data << ((readBannerBytes - 18) * 8));                banner.setVirtualHeight(virtualHeight);                break;            case 22:                // orientation                banner.setOrientation(data * 90);                break;            case 23:                // quirks                banner.setQuirks(data);                break;            default:        }        readBannerBytes ++;        if (readBannerBytes == bannerLength) {            log.info("Banner: {}", banner);        }    }    /**     * 将一帧放入到队列     */    protected void offer(byte[] frame) {        if (frameQueue.size() >= queueSize) {            frameQueue.poll();            log.debug("存放帧的队列已满，将会抛弃最旧的一帧");        }        long start = System.currentTimeMillis();        frameQueue.offer(frame);        if(recorder != null) {            recorder.offer(frame);        }        long end = System.currentTimeMillis();        log.debug(String.valueOf(end -  start));    }    /**     * 检查是否关闭     */    protected void checkClosed() {        if (!this.isRunning.get()) {            throw new IllegalStateException("Minicap客户端已关闭");        }    }    /**     * 初始化     */    protected void init() {        this.frameQueue = new LinkedBlockingQueue<>(queueSize);    }    /**     * 重置     */    protected void reset() {        this.banner = null;        this.readBannerBytes = 0;        this.bannerLength = 2;        this.readFrameBytes = 0;        this.frameBodyLength = 0;    }    public static void main(String[] args) {        MinicapClient s = new MinicapClient(7501);        s.start();    }}