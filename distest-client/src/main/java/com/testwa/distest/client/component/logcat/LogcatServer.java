package com.testwa.distest.client.component.logcat;import com.android.ddmlib.IDevice;import com.android.ddmlib.IShellOutputReceiver;import com.testwa.core.shell.UTF8CommonExecs;import com.testwa.distest.client.android.AndroidHelper;import com.testwa.distest.client.ios.IOSDeviceUtil;import io.rpc.testwa.device.DeviceType;import lombok.extern.slf4j.Slf4j;import org.apache.commons.exec.CommandLine;import org.apache.commons.exec.ExecuteStreamHandler;import org.apache.commons.exec.PumpStreamHandler;import org.apache.commons.lang3.StringUtils;import java.io.ByteArrayOutputStream;import java.io.Closeable;import java.io.IOException;import java.nio.file.Files;import java.nio.file.StandardOpenOption;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;import static org.apache.commons.exec.ExecuteWatchdog.INFINITE_TIMEOUT;/** * @Program: distest * @Description: logcat 收集 * @Author: wen * @Create: 2018-07-12 11:38 **/@Slf4jpublic class LogcatServer extends Thread implements Closeable {    /** 队列大小 */    private int queueSize = 500;    /** 存放日志队列 */    private BlockingQueue<byte[]> logQueue;    /** 调用take的线程 */    private Thread takeThread;    /** 执行 logcat 的设备 */    private IDevice device;    private String deviceId;    /** 设备类型*/    private DeviceType deviceType;    /** 是否运行 */    private AtomicBoolean isRunning = new AtomicBoolean(false);    /** 是否重启 */    private AtomicBoolean restart = new AtomicBoolean(false);    private UTF8CommonExecs execs;    public LogcatServer(String deviceId, DeviceType deviceType){        super("Logcat-server");        this.deviceType = deviceType;        if(DeviceType.ANDROID.equals(deviceType)) {            this.device = AndroidHelper.getInstance().getAndroidDevice(deviceId).getDevice();        }        if(DeviceType.IOS.equals(deviceType)){            this.deviceId = deviceId;        }        init();    }    /**     * 获取每一行数据，如果没有则阻塞     * @return     * @throws InterruptedException 阻塞中断     */    public synchronized byte[] take() throws InterruptedException {        checkClosed();        takeThread = Thread.currentThread();        return logQueue.take();    }    /**     * 是否运行     * @return true 已运行 false 未运行     */    public boolean isRunning() {        return this.isRunning.get();    }    @Override    public void close() {        if(this.execs != null) {            this.execs.destroy();        }        this.isRunning.set(false);        this.restart.set(true);    }    /**     * 重启     */    public void restart() {        this.isRunning.set(true);        this.restart.set(true);    }    @Override    public synchronized void start() {        if (this.isRunning.get()) {            throw new IllegalStateException("Logcat 服务已运行");        } else {            this.isRunning.set(true);        }        super.start();    }    @Override    public void run() {        while (this.isRunning.get()) {            if(DeviceType.ANDROID.equals(deviceType)) {                try {                    device.executeShellCommand(getClearCommand(), new IShellOutputReceiver() {                        @Override                        public void addOutput(byte[] bytes, int i, int i1) {                        }                        @Override                        public void flush() {                        }                        @Override                        public boolean isCancelled() {                            return false;                        }                    });                    String command = getCommand();                    log.info("拉起 Logcat 服务 command: {}", command);                    device.executeShellCommand(command, new IShellOutputReceiver() {                        @Override                        public void addOutput(byte[] bytes, int i, int i1) {//                        try {//                            Files.write(logcatTempFile, bytes, StandardOpenOption.APPEND);//                        } catch (IOException e) {//                            log.error("write to {} error", logcatTempFile, e);//                        }                            offer(bytes);                        }                        @Override                        public void flush() {                        }                        @Override                        public boolean isCancelled() {                            boolean result = restart.get();                            restart.set(false);                            return result;                        }                    }, Integer.MAX_VALUE, TimeUnit.DAYS);                } catch (Exception e) {                    log.warn("{} Logcat 服务运行异常, {}", device.getSerialNumber(), e.getMessage());                }            }            if(DeviceType.IOS.equals(deviceType)) {                if(IOSDeviceUtil.isOnline(deviceId)) {                    try {                        CommandLine commandLine = IOSDeviceUtil.getLogCmd(this.deviceId);                        log.info("拉起 ios log 服务 command: {}", commandLine.toString().replace(",", ""));                        execs = new UTF8CommonExecs(commandLine);                        execs.setTimeout(INFINITE_TIMEOUT);                        execs.asyncexec();                    } catch (Exception e) {                        String out = execs.getOutput();                        String error = execs.getError();                        log.warn("iOS {} Log服务运行异常, {} {}", this.deviceId, out, error);                    }                    while (this.isRunning.get()) {                        try {                            TimeUnit.SECONDS.sleep(1);                        } catch (InterruptedException e) {                        }                        String outputLog = execs.getOutput();                        offer(outputLog.getBytes());                    }                }            }        }        this.isRunning.set(false);        if(this.execs != null) {            this.execs.destroy();        }        log.info("Logcat 服务已关闭");    }    private String getClearCommand(){        return "logcat -c";    }    private String getCommand(){        return "logcat -v threadtime";    }    private void init(){        this.logQueue = new LinkedBlockingQueue<>(queueSize);    }    /**     * 将一行放入到队列     */    protected void offer(byte[] data) {        if (logQueue.size() >= queueSize) {            logQueue.poll();            log.debug("存放的队列已满，将会抛弃最旧的一行");        }        logQueue.offer(data);    }    /**     * 检查是否关闭     */    protected void checkClosed() {        if (!this.isRunning.get()) {            throw new IllegalStateException("Logcat服务端已关闭");        }    }}