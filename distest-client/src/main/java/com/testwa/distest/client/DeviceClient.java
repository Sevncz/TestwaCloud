package com.testwa.distest.client;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.android.ddmlib.IDevice;import com.google.protobuf.ByteString;import com.testwa.core.cmd.RemoteRunCommand;import com.testwa.distest.client.android.ADBCommandUtils;import com.testwa.distest.client.android.AndroidHelper;import com.testwa.distest.client.android.PhysicalSize;import com.testwa.distest.client.component.Constant;import com.testwa.distest.client.component.appium.utils.Config;import com.testwa.distest.client.component.executor.*;import com.testwa.distest.client.component.logcat.DLogger;import com.testwa.distest.client.component.logcat.LogListener;import com.testwa.distest.client.component.minicap.*;import com.testwa.distest.client.callback.DefaultObserver;import com.testwa.distest.client.component.minitouch.TouchProjection;import com.testwa.distest.client.exception.DeviceNotReadyException;import com.testwa.distest.client.ios.IOSDeviceUtil;import com.testwa.distest.client.service.Gvice;import io.grpc.Channel;import io.rpc.testwa.device.DeviceType;import io.rpc.testwa.device.LogcatRequest;import io.rpc.testwa.device.ScreenCaptureRequest;import io.rpc.testwa.push.ClientInfo;import io.rpc.testwa.push.PushGrpc;import io.rpc.testwa.push.Status;import io.rpc.testwa.push.TopicInfo;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicReference;/** * @Program: distest * @Description: * @Author: wen * @Create: 2018-05-08 16:27 **/@Slf4jpublic class DeviceClient implements ScreenListener, LogListener, TestTaskListener {    private final PushGrpc.PushStub asyncStub;    private final PushGrpc.PushBlockingStub blockingStub;    private final Channel channel;    private final String clientId;    private final String userToken;    private final ClientInfo clientInfo;    private boolean isWaitting = false;    private boolean isLogcatWaitting = false;    private DeviceType deviceType;    private ScreenAndroidProjection screenAndroidProjection = null;    private ScreenIOSProjection screenIOSProjection = null;    private TouchProjection touchProjection = null;    private DLogger dLogger = null;    private AbstractTestTask task = null;    private int buildClientInfoMaxTime = 10;    private final AtomicReference<Thread> currentTaskThread;    private final AtomicReference<ExecutorService> es;    private String videoOutputFile;    public DeviceClient(String deviceId, Channel channel, String userToken, DeviceType deviceType) throws DeviceNotReadyException {        this.deviceType = deviceType;        this.clientId = deviceId;        this.userToken = userToken;        this.channel = channel;        this.asyncStub = PushGrpc.newStub(channel);        this.blockingStub = PushGrpc.newBlockingStub(channel);        this.clientInfo = buildClientInfo();        ExecutorService taskWorker = Executors.newSingleThreadExecutor();        es = new AtomicReference<>();        es.set(taskWorker);        currentTaskThread = new AtomicReference<>();        if(DeviceType.ANDROID.equals(deviceType)) {            es.get().submit(() -> {                // 检查输入法是否已经安装                boolean isInstall = ADBCommandUtils.isInstalledBasepackage(clientId, "com.android.adbkeyboard");                if(!isInstall){                    // install 支持中文输入的输入法                    String resourcesPath = Config.getString("distest.agent.resources");                    String keyboardPath = resourcesPath + File.separator + Constant.getKeyboardService();                    if(Files.exists(Paths.get(keyboardPath))){                        ADBCommandUtils.installApp(clientId, keyboardPath);                    }                }else{                    ADBCommandUtils.switchADBKeyBoard(clientId);                }            });        }        log.info("设备 {} {} 初始化 ", clientInfo.getBrand(), clientInfo.getModel());    }    /**     * grpc     */    public void resendRegister(DefaultObserver defaultObserver) {        this.asyncStub.registerToServer(this.clientInfo, defaultObserver);    }    public void registerToServer(){        this.asyncStub.registerToServer(this.clientInfo, new DefaultObserver(this.clientId, this));    }    public String subscribe(String topic){        TopicInfo topicInfo = TopicInfo.newBuilder().setTopicName(topic).setClientInfo(this.clientInfo).build();        Status status = this.blockingStub.subscribe(topicInfo);        return status.getStatus();    }    public String cancel(String topic){        TopicInfo topicInfo = TopicInfo.newBuilder().setTopicName(topic).setClientInfo(this.clientInfo).build();        Status status = this.blockingStub.cancel(topicInfo);        return status.getStatus();    }    public String logoutFromServer(){        Status status = this.blockingStub.logoutFromServer(this.clientInfo);        return status.getStatus();    }    public String getClientId() {        return clientId;    }    public ClientInfo buildClientInfo() throws DeviceNotReadyException {        if(DeviceType.ANDROID.equals(this.deviceType)) {            IDevice dev = AndroidHelper.getInstance().getAndroidDevice(this.clientId).getDevice();            if(dev != null && dev.isOnline()){                String brand = dev.getProperty("ro.product.brand");                if(StringUtils.isBlank(brand)){                    if(buildClientInfoMaxTime <= 0){                        throw new DeviceNotReadyException("无法获取设备属性");                    }                    buildClientInfoMaxTime--;                    try {                        TimeUnit.SECONDS.sleep(1);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    return buildClientInfo();                }                String cpuabi = dev.getProperty(IDevice.PROP_DEVICE_CPU_ABI);                String sdk = dev.getProperty(IDevice.PROP_BUILD_API_LEVEL);                String host = dev.getProperty("ro.build.host");                String model = dev.getProperty(IDevice.PROP_DEVICE_MODEL);                String version = dev.getProperty(IDevice.PROP_BUILD_VERSION);                String density = dev.getDensity() + "";                PhysicalSize size = ADBCommandUtils.getPhysicalSize(dev.getSerialNumber());                String width = String.valueOf(size.getWidth());                String height = String.valueOf(size.getHeight());                return ClientInfo.newBuilder()                        .setDeviceId(dev.getSerialNumber())                        .setBrand(brand)                        .setCpuabi(cpuabi)                        .setDensity(density)                        .setHeight(height)                        .setWidth(width)                        .setHost(host)                        .setModel(model)                        .setOsName("Android")                        .setSdk(sdk)                        .setUserFlag(userToken)                        .setVersion(version)                        .build();            }else{                throw new DeviceNotReadyException("设备不在线，无法初始化");            }        }else{            String cpu = IOSDeviceUtil.getCPUArchitecture(clientId);            String productType = IOSDeviceUtil.getProductType(clientId);            String productVersion = IOSDeviceUtil.getProductVersion(clientId);            return ClientInfo.newBuilder()                    .setDeviceId(clientId)                    .setBrand("Apple")                    .setCpuabi(cpu)                    .setModel(productType)                    .setOsName("iOS")                    .setUserFlag(userToken)                    .setVersion(productVersion)                    .build();        }    }    public void stop() {        // 关闭组件        stopMinicap();        stopMinitouch();        if (task != null) {            task.kill();        }        this.setWaitting(true);        this.es.get().shutdown();    }    @Override    public void projection(byte[] data) {        // for video queue//        toVideoDataQueue.add(new LocalClient.ImageData(data));        // for pic queue        if (!isWaitting) {            sendImage(data);        }    }    public void setWaitting(boolean waitting) {        log.info("set waitting = {}", waitting);        isWaitting = waitting;    }    private void sendImage(byte[] data) {        try {            ScreenCaptureRequest request = ScreenCaptureRequest.newBuilder()                    .setImg(ByteString.copyFrom(data))                    .setName("xxx")                    .setSerial(this.clientId)                    .build();            Gvice.deviceService(this.channel).screen(request);        }catch (Exception e){            log.error(e.getMessage());        }finally {        }    }    public void startMinicap(String command) {        this.setWaitting(false);        long startTime = System.currentTimeMillis();        log.warn("{} ready to start minicap, time: {}", clientInfo.getModel(), startTime);        // 获取请求的配置        JSONObject obj = JSON.parseObject(command);        Float scale = obj.getFloat("scale");        Integer rotate = obj.getInteger("rotate");//        scale = 0.2f;        if (scale == null) {scale = 0.3f;}        if (scale < 0.01) {scale = 0.01f;}        if (scale > 1.0) {scale = 1.0f;}        if (rotate == null) { rotate = 0; }        int quality = 25;        String resolution = obj.getString("resolution");        if(DeviceType.ANDROID.equals(this.deviceType)) {            if(this.screenAndroidProjection != null && this.screenAndroidProjection.isAlive()){                this.screenAndroidProjection.setZoom(scale);                this.screenAndroidProjection.setRotate(rotate);                this.screenAndroidProjection.setQuality(quality);                if(this.screenAndroidProjection.isRunning()) {                    this.screenAndroidProjection.restart();                }else{                    screenAndroidProjectionStart(scale, rotate, quality);                }            }else{                screenAndroidProjectionStart(scale, rotate, quality);            }        }else{            if(StringUtils.isBlank(resolution)) {                resolution = "400x600";            }            if(this.screenIOSProjection != null && this.screenIOSProjection.isAlive()){                this.screenIOSProjection.setResolution(resolution);                if(this.screenIOSProjection.isRunning()) {                    this.screenIOSProjection.restart();                }else{                    screenIOSProjectionStart(resolution);                }            }else{                screenIOSProjectionStart(resolution);            }        }        Long endTime = System.currentTimeMillis();        try {            TimeUnit.SECONDS.sleep(2);        } catch (InterruptedException e) {        }    }    private void screenAndroidProjectionStart(Float scale, Integer rotate, int quality) {        this.screenAndroidProjection = new ScreenAndroidProjection(clientId, this);        this.screenAndroidProjection.setZoom(scale);        this.screenAndroidProjection.setRotate(rotate);        this.screenAndroidProjection.setQuality(quality);        this.screenAndroidProjection.start();    }    private void defaultVideoRecorderStart(Long taskCode) {        // 录制视频输出文件        Path videoPath = Paths.get(Constant.localVideoPath, this.clientId, taskCode + ".mp4");        if(!Files.exists(videoPath)) {            try {                Files.createDirectories(videoPath.getParent());//                Files.createFile(videoPath);            } catch (IOException e) {            }        }        this.videoOutputFile = Paths.get(Constant.localVideoPath, this.clientId, taskCode + ".mp4").toString();        log.info("videoOutputFile ------ {}", videoOutputFile);        videoRecorderStart(0.4f, 0, 80, this.videoOutputFile);    }    private void videoRecorderStart(Float scale, Integer rotate, int quality, String outputFile) {        this.screenAndroidProjection = new ScreenAndroidProjection(clientId, this);        this.screenAndroidProjection.setZoom(scale);        this.screenAndroidProjection.setRotate(rotate);        this.screenAndroidProjection.setQuality(quality);        this.screenAndroidProjection.initRecorder(outputFile);        this.screenAndroidProjection.start();    }    private void screenIOSProjectionStart(String resolution) {        this.screenIOSProjection = new ScreenIOSProjection(clientId, this);        this.screenIOSProjection.setResolution(resolution);        this.screenIOSProjection.start();    }    public void startMinitouch() {        if(DeviceType.ANDROID.equals(this.deviceType)) {            if (touchProjection != null) {                touchProjection.close();            }            this.touchProjection = new TouchProjection(clientId);            this.touchProjection.start();        }    }    public void stopMinicap() {        if (this.screenAndroidProjection != null) {            this.screenAndroidProjection.close();        }        if (this.screenIOSProjection != null) {            this.screenIOSProjection.close();        }    }    public void stopMinitouch() {        if (this.touchProjection != null) {            this.touchProjection.close();        }    }    public void keyevent(Integer code) {        if (this.touchProjection != null) this.touchProjection.sendCode(code);    }    public void touch( String command) {        if (this.touchProjection != null) this.touchProjection.sendEvent(command);    }    /**     * 等待时，关闭logcat     * @param     */    public void stopLogcat() {        if(this.dLogger != null){            this.dLogger.close();        }    }    /**     * 再次发送命令下来时，重新打开logcat     * @param command     */    public void startLogcat(String command) {        if(this.dLogger != null){            this.dLogger.close();        }        this.isLogcatWaitting = true;        dLogger = new DLogger(this.clientId, this);        dLogger.setContent(command);        dLogger.start();    }    public void onLog(byte[] bytes) {        try {            LogcatRequest request = LogcatRequest.newBuilder()                    .setSerial(clientId)                    .setContent(ByteString.copyFrom(bytes))                    .build();            Gvice.deviceService(this.channel).logcat(request);        }catch (Exception e){            log.error(e.getMessage());        }finally {        }    }    /**     *@Description: 开始执行测试任务     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void startTask(String command) {        log.info("设备 {}，开始任务 {}", clientId, command);        stopCurrentTask();        RemoteRunCommand cmd = JSON.parseObject(command, RemoteRunCommand.class);//        defaultVideoRecorderStart(cmd.getTaskCode());        Future<?> future = es.get().submit(() -> {            Thread currentThread = Thread.currentThread();            setCurrentTaskThread(currentThread);            task = new HGTestTask(cmd, this);            task.start();        });    }    /**     * 兼容测试     */    public void startJRTask(String command) {        log.info("设备 {}，开始兼容任务 {}", clientId, command);        stopCurrentTask();        RemoteRunCommand cmd = JSON.parseObject(command, RemoteRunCommand.class);//        defaultVideoRecorderStart(cmd.getTaskCode());        Future<?> future = es.get().submit(() -> {            Thread currentThread = Thread.currentThread();            setCurrentTaskThread(currentThread);            task = new JRAndroidTestTask(cmd, this);            task.start();        });    }    /**     * 遍历测试     */    public void startCrawlerTask(String command) {        log.info("设备 {}，开始遍历任务 {}", clientId, command);        stopCurrentTask();        RemoteRunCommand cmd = JSON.parseObject(command, RemoteRunCommand.class);//        defaultVideoRecorderStart(cmd.getTaskCode());        Future<?> future = es.get().submit(() -> {            Thread currentThread = Thread.currentThread();            setCurrentTaskThread(currentThread);            task = new CrawlerTestTask(cmd, this);            task.start();        });    }    /**     *@Description: 取消在该设备正在执行的任务     *@Param: [command]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void cancelTask(Long taskCode) {        if(task != null){            RemoteRunCommand cmd = task.getCMD();            if(taskCode.equals(cmd.getTaskCode())) {                task.kill();                stopCurrentTask();                task = null;            }        }    }    private void stopCurrentTask() {        if(currentTaskThread.get() != null){            while (currentTaskThread.get().isAlive()) {                currentTaskThread.get().stop();                try {                    TimeUnit.MILLISECONDS.sleep(50);                } catch (InterruptedException e) {                }            }        }    }    private void setCurrentTaskThread(Thread currentThread) {        currentTaskThread.set(currentThread);        currentThread.setUncaughtExceptionHandler((t1, e) -> {            if (e instanceof ThreadDeath || e instanceof IllegalMonitorStateException) {                e.printStackTrace();                es.get().shutdownNow();                es.set(Executors.newSingleThreadExecutor());            }        });    }    /**     *@Description: 任务执行完成的回调     *@Param: []     *@Return: void     *@Author: wen     *@Date: 2018/7/10     */    @Override    public void taskFinish() {        this.screenAndroidProjection.close();        // 上传测试录像        log.info("upload mp4 file for task");    }}