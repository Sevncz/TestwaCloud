package com.testwa.distest.client;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.android.ddmlib.IDevice;import com.android.ddmlib.Log;import com.google.protobuf.ByteString;import com.testwa.core.cmd.KeyCode;import com.testwa.core.cmd.RemoteRunCommand;import com.testwa.distest.client.android.*;import com.testwa.distest.client.callback.remote.ScreenObserver;import com.testwa.distest.client.component.Constant;import com.testwa.distest.client.component.appium.utils.Config;import com.testwa.distest.client.component.debug.AndroidDebugServer;import com.testwa.distest.client.component.executor.task.*;import com.testwa.distest.client.component.logcat.DLogger;import com.testwa.distest.client.component.logcat.LogCatFilter;import com.testwa.distest.client.component.logcat.LogCatMessage;import com.testwa.distest.client.component.logcat.LogListener;import com.testwa.distest.client.component.minicap.*;import com.testwa.distest.client.callback.DefaultObserver;import com.testwa.distest.client.component.minitouch.TouchAndroidProjection;import com.testwa.distest.client.component.port.SocatPortProvider;import com.testwa.distest.client.component.port.TcpIpPortProvider;import com.testwa.distest.client.component.wda.driver.DriverCapabilities;import com.testwa.distest.client.component.wda.driver.IOSDriver;import com.testwa.distest.client.exception.DeviceNotReadyException;import com.testwa.distest.client.ios.FrameCounter;import com.testwa.distest.client.ios.IOSDeviceUtil;import com.testwa.distest.client.ios.IOSPhysicalSize;import com.testwa.distest.client.model.AgentInfo;import com.testwa.distest.client.service.Gvice;import com.testwa.distest.client.util.ImgCompress;import com.testwa.distest.jadb.JadbDevice;import com.testwa.distest.jadb.JadbException;import io.grpc.Channel;import io.grpc.stub.StreamObserver;import io.rpc.testwa.device.*;import io.rpc.testwa.push.*;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import java.io.*;import java.math.BigDecimal;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicReference;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * @Program: distest * @Description: * @Author: wen * @Create: 2018-05-08 16:27 **/@Deprecated@Slf4jpublic class DeviceClient implements LogListener, TestTaskListener {    private final PushGrpc.PushStub asyncStub;    private final PushGrpc.PushBlockingStub blockingStub;    private final Channel channel;    private final DeviceServiceGrpc.DeviceServiceStub deviceSyncService;    private final StreamObserver<ScreenCaptureRequest>  screenRequestObserver;    private final String clientId;    private final String userToken;    private final AtomicReference<ClientInfo> clientInfo = new AtomicReference<>();    private boolean isWaitting = false;    private boolean isLogcatWaitting = false;    private DeviceType deviceType;    private ScreenAndroidProjection screenAndroidProjection = null;    private ScreenIOSProjection screenIOSProjection = null;    private TouchAndroidProjection touchProjection = null;    private DLogger dLogger = null;    private AbstractTestTask task = null;    private int buildClientInfoMaxTime = 10;    private String videoOutputFile;    /**     * 在Android的ADB的情况下，我们是使用adb logcat -v brief -v threadtime     */    private final static String adb_log_line_regex = "(.\\S*) *(.\\S*) *(\\d*) *(\\d*) *([A-Z]) *([^:]*): *(.*?)$";    /**     * ios 日志格式匹配     */    private final static String ios_log_line_regex = "(.\\S*) *(.\\S*) *(\\d*) *(\\d*) *([A-Z]) *([^:]*): *(.*?)$";    private LogCatFilter logCatFilter;    private Pattern logAndroidPattern;    private Pattern logIOSPattern;    private String resourcePath;    private static final String PATH_SERVICE_APK = "STFService" + File.separator + "STFService.apk";    private static final String PATH_APPIUM_UIAUTOMATOR_SERVER = "appium" + File.separator + "appium-uiautomator2-server.apk";    private static final String PATH_APPIUM_UIAUTOMATOR_DEBUG = "appium" + File.separator + "appium-uiautomator2-server-debug-androidTest.apk";    private static final String PATH_KEYBOARDSERVICE = "keyboardservice" + File.separator + "keyboardservice-debug.apk";    /**     * appium 相关包     */    private static final String UNICODEIME_PACKAGE = "io.appium.android.ime";    private static final String UI2_SERVER_PACKAGE = "io.appium.uiautomator2.server";    private static final String UI2_DEBUG_PACKAGE = "io.appium.uiautomator2.server.test";//    private static final String SELENDROID_SERVER_PACKAGE = "io.selendroid.server";//    private static final String SETTINGS_PACKAGE = "io.appium.settings.Settings";//    private static final String UNLOCK_PACKAGE = "io.appium.unlock";    /**     * stf 相关包     */    private static final String STF_SERVICE_PACKAGE = "jp.co.cyberagent.stf";    /**     * keyboardservice 相关包     */    private static final String KEYBOARD_SERVICE_PACKAGE = "com.android.adbkeyboard";    /**     * 屏幕显示标准大小     */    private static final int BASE_WIDTH = 720;    private float defaultScale = 0.5f;    private IOSDriver iosDriver;    private DriverCapabilities iosDriverCapabilities;    // 帧计数器    private FrameCounter frameCounter;    private final int tcpipPort;    private final int socatPort;    private AndroidDebugServer androidDebugServer;    private boolean enabledTcpip = false;    private Long tcpipTime;    private DefaultObserver observer;    /**     * 毫秒     * 超过该时间再断开，即算断开     */    private static final Long TCPIP_TIMEOUT = 20*1000L;    /**     * wda配置     */    private static final String WDA_PROJECT = "WebDriverAgent.xcodeproj";    private static final String WDA_SCHEME = "WdaServer";    public DeviceClient(String deviceId, Channel channel, String userToken, DeviceType deviceType) {        this.resourcePath = Config.getString("distest.agent.resources");        this.deviceType = deviceType;        this.clientId = deviceId;        this.userToken = userToken;        this.channel = channel;        this.deviceSyncService = Gvice.deviceAsyncService(this.channel);        ScreenObserver screenObserver = new ScreenObserver();        this.screenRequestObserver = this.deviceSyncService.screen(screenObserver);        this.frameCounter = new FrameCounter();        this.asyncStub = PushGrpc.newStub(channel);        this.blockingStub = PushGrpc.newBlockingStub(channel);        this.logAndroidPattern = Pattern.compile(adb_log_line_regex);        this.logIOSPattern = Pattern.compile(ios_log_line_regex);        this.tcpipPort = TcpIpPortProvider.pullPort();        this.socatPort = SocatPortProvider.pullPort();        this.observer = new DefaultObserver(this.clientId, this);    }    public void initClient() throws DeviceNotReadyException {        this.clientInfo.set(this.buildClientInfo());        log.info("设备 {} {} {} 初始化 ", clientInfo.get().getBrand(), clientInfo.get().getModel(), clientInfo.get().getDeviceId());    }    private void initTcpipCommand() {        if(DeviceType.ANDROID.equals(this.deviceType)) {            JadbDevice jadbDevice = JadbDeviceManager.getJadbDevice(this.clientId);            try {                jadbDevice.enableAdbOverTCP(this.tcpipPort);                this.tcpipTime = System.currentTimeMillis();                this.enabledTcpip = true;            } catch (IOException | JadbException e) {                log.error("tcpip 命令执行失败", e);            }        }    }    public boolean checkCanStop() {        // 检查是不是tcpip命令已执行成功        if(DeviceType.ANDROID.equals(this.deviceType)) {            if(this.enabledTcpip){                // 检查是否超时                Long currentTime = System.currentTimeMillis();                if((currentTime - tcpipTime) > TCPIP_TIMEOUT) {                    return true;                }            }        }else{            return true;        }        return false;    }    /**     * grpc     */    public void resendRegister(DefaultObserver defaultObserver) {        this.asyncStub.registerToServer(this.clientInfo.get(), defaultObserver);    }    public void registerToServer(){        this.asyncStub.registerToServer(this.clientInfo.get(), this.observer);    }    public String subscribe(String topic){        TopicInfo topicInfo = TopicInfo.newBuilder().setTopicName(topic).setClientInfo(this.clientInfo.get()).build();        Status status = this.blockingStub.subscribe(topicInfo);        return status.getStatus();    }    public String cancel(String topic){        TopicInfo topicInfo = TopicInfo.newBuilder().setTopicName(topic).setClientInfo(this.clientInfo.get()).build();        Status status = this.blockingStub.cancel(topicInfo);        return status.getStatus();    }    public String logoutFromServer(){        Status status = this.blockingStub.logoutFromServer(this.clientInfo.get());        return status.getStatus();    }    public String getClientId() {        return clientId;    }    private ClientInfo buildClientInfo() throws DeviceNotReadyException {        AgentInfo agentInfo = AgentInfo.getAgentInfo();        if(DeviceType.ANDROID.equals(this.deviceType)) {            IDevice dev = AndroidHelper.getInstance().getAndroidDevice(this.clientId).getDevice();            if(dev != null && dev.isOnline()){                String brand = dev.getProperty("ro.product.brand");                if(StringUtils.isBlank(brand)){                    if(buildClientInfoMaxTime <= 0){                        throw new DeviceNotReadyException("无法获取设备属性");                    }                    buildClientInfoMaxTime--;                    try {                        TimeUnit.SECONDS.sleep(1);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    return buildClientInfo();                }                String cpuabi = dev.getProperty(IDevice.PROP_DEVICE_CPU_ABI);                String sdk = dev.getProperty(IDevice.PROP_BUILD_API_LEVEL);                String host = dev.getProperty("ro.build.host");                String model = dev.getProperty(IDevice.PROP_DEVICE_MODEL);                String version = dev.getProperty(IDevice.PROP_BUILD_VERSION);                String density = dev.getDensity() + "";                PhysicalSize size = ADBCommandUtils.getPhysicalSize(dev.getSerialNumber());                // 设置默认scale                if(size.getWidth() >= BASE_WIDTH) {                    double rate = BASE_WIDTH / (size.getWidth()*1.0);                    this.defaultScale = BigDecimal.valueOf(rate).setScale(1, BigDecimal.ROUND_HALF_UP).floatValue();                }                String width = String.valueOf(size.getWidth());                String height = String.valueOf(size.getHeight());                // 检查 uiautomator2、stfagent 等组件的安装情况                boolean stfagentInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), STF_SERVICE_PACKAGE);                if(!stfagentInstall) {                    log.warn("{} 未安装 {}", dev.getName(), STF_SERVICE_PACKAGE);                }                boolean appiumServerInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), UI2_SERVER_PACKAGE);                if(!appiumServerInstall) {                    log.warn("{} 未安装 {}", dev.getName(), UI2_SERVER_PACKAGE);                }                boolean appiumDebugInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), UI2_DEBUG_PACKAGE);                if(!appiumDebugInstall) {                    log.debug("{} 未安装 {}", dev.getName(), UI2_DEBUG_PACKAGE);                }//                boolean settingsInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), SETTINGS_PACKAGE);//                if(!settingsInstall) {//                    log.warn("{} 未安装 {}", dev.getName(), SETTINGS_PACKAGE);//                }//                boolean unlockInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), UNLOCK_PACKAGE);//                if(!unlockInstall) {//                    log.warn("{} 未安装 {}", dev.getName(), UNLOCK_PACKAGE);//                }                boolean unicodeIMEInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), UNICODEIME_PACKAGE);                if(!unicodeIMEInstall) {                    log.debug("{} 未安装 {}", dev.getName(), UNICODEIME_PACKAGE);                }//                boolean selendroidInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), SELENDROID_SERVER_PACKAGE);//                if(!selendroidInstall) {//                    log.warn("{} 未安装 {}", dev.getName(), SELENDROID_SERVER_PACKAGE);//                }                boolean keyboardserviceInstall = ADBCommandUtils.isInstalledBasepackage(dev.getSerialNumber(), KEYBOARD_SERVICE_PACKAGE);                if(!keyboardserviceInstall) {                    log.warn("{} 未安装 {}", dev.getName(), KEYBOARD_SERVICE_PACKAGE);                }                initTcpipCommand();                return ClientInfo.newBuilder()                        .setDeviceId(dev.getSerialNumber())                        .setBrand(brand)                        .setCpuabi(cpuabi)                        .setDensity(density)                        .setHeight(height)                        .setWidth(width)                        .setHost(host)                        .setModel(model)                        .setOsName("Android")                        .setSdk(sdk)                        .setUserFlag(userToken)                        .setVersion(version)                        .setSftagentInstall(stfagentInstall)                        .setAppiumUiautomator2ServerInstall(appiumServerInstall)                        .setAppiumUiautomator2DebugInstall(appiumDebugInstall)                        .setKeyboardserviceInstall(keyboardserviceInstall)//                        .setSelendroidInstall(selendroidInstall)//                        .setSettingsInstall(settingsInstall)                        .setUnicodeIMEInstall(unicodeIMEInstall)//                        .setUnlockInstall(unlockInstall)                        .setRemoteConnectPort(this.socatPort)                        .setIp(agentInfo.getHost())                        .setTcpipCommandSuccessed(this.enabledTcpip)                        .build();            }else{                throw new DeviceNotReadyException("设备不在线，无法初始化");            }        }else{            String cpu = IOSDeviceUtil.getCPUArchitecture(clientId);            String model = IOSDeviceUtil.getModel(clientId);            String productVersion = IOSDeviceUtil.getProductVersion(clientId);            IOSPhysicalSize size = IOSDeviceUtil.getSize(clientId);            String width = String.valueOf(size.getPhsicalWidth());            String height = String.valueOf(size.getPhsicalHeight());            String wdaHome = Config.getString("wda.home");            Path wdaProject = Paths.get(wdaHome, WDA_PROJECT);            double scale = (size.getPointWidth() * 1.0)/size.getPhsicalWidth();            this.iosDriverCapabilities= new DriverCapabilities();            this.iosDriverCapabilities.setDeviceId(clientId);            this.iosDriverCapabilities.setWdaPath(wdaProject.toString());            this.iosDriverCapabilities.setSale(String.valueOf(scale));            return ClientInfo.newBuilder()                    .setDeviceId(clientId)                    .setBrand("Apple")                    .setCpuabi(cpu)                    .setModel(model)                    .setOsName("iOS")                    .setUserFlag(userToken)                    .setVersion(productVersion)                    .setWidth(width)                    .setHeight(height)                    .setIp(agentInfo.getHost())                    .build();        }    }    public void stop() {        // 关闭组件        stopMinicap();        stopMinitouch();        if (task != null) {            task.terminate();        }        this.setWaitting(true);    }    public void setWaitting(boolean waitting) {        log.info("set waitting = {}", waitting);        isWaitting = waitting;    }    private void sendImage(byte[] data) {        try {            ScreenCaptureRequest request = ScreenCaptureRequest.newBuilder()                    .setImg(ByteString.copyFrom(data))                    .setName("xxx")                    .setSerial(this.clientId)                    .build();            this.screenRequestObserver.onNext(request);        }catch (Exception e){            log.error(e.getMessage());        }finally {        }    }    public void startMinicap(String command) {        this.setWaitting(false);        long startTime = System.currentTimeMillis();        log.warn("{} ready to start minicap, time: {}", clientInfo.get().getModel(), startTime);        // 获取请求的配置        JSONObject obj = JSON.parseObject(command);        Float scale = obj.getFloat("scale");        // 设置缩放        if (scale == null) {scale = defaultScale;}        if (scale < 0.01) {scale = 0.01f;}        if (scale > 1.0) {scale = 1.0f;}        // 设置旋转        Integer rotate = obj.getInteger("rotate");        if (rotate == null) { rotate = 0; }        // 设置画质        int quality = 25;        String resolution = obj.getString("resolution");        if(DeviceType.ANDROID.equals(this.deviceType)) {//            if(this.screenAndroidProjection != null && this.screenAndroidProjection.isAlive()){//                this.screenAndroidProjection.setZoom(scale);//                this.screenAndroidProjection.setRotate(rotate);//                this.screenAndroidProjection.setQuality(quality);//                if(this.screenAndroidProjection.isRunning()) {//                    this.screenAndroidProjection.restart();//                }else{//                    screenAndroidProjectionStart(scale, rotate, quality);//                }//            }else{//                screenAndroidProjectionStart(scale, rotate, quality);            }//        }else{//            if(StringUtils.isBlank(resolution)) {//                resolution = "400x600";//            }//            if(this.screenIOSProjection != null && this.screenIOSProjection.isAlive()){//                if(this.screenIOSProjection.isRunning()) {//                    this.screenIOSProjection.restart();//                }else{//                    screenIOSProjectionStart();//                }//            }else{//                screenIOSProjectionStart();//            }////        }        Long endTime = System.currentTimeMillis();        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {        }    }    private void screenAndroidProjectionStart(Float scale, Integer rotate, int quality) {        if(this.screenAndroidProjection != null) {            this.screenAndroidProjection.close();        }//        this.screenAndroidProjection = new ScreenAndroidProjection(clientId, resourcePath, this);//        this.screenAndroidProjection.setZoom(scale);//        this.screenAndroidProjection.setRotate(rotate);//        this.screenAndroidProjection.setQuality(quality);//        this.screenAndroidProjection.start();    }    private void defaultVideoRecorderStart(Long taskCode) {        // 录制视频输出文件        Path videoPath = Paths.get(Constant.localVideoPath, this.clientId, taskCode + ".mp4");        if(!videoPath.toFile().exists()) {            try {                Files.createDirectories(videoPath.getParent());            } catch (IOException e) {            }        }        this.videoOutputFile = videoPath.toString();        log.info("视频输出至：{}", videoOutputFile);        videoRecorderStart(defaultScale, 0, 80, this.videoOutputFile);    }    private void videoRecorderStart(Float scale, Integer rotate, int quality, String outputFile) {        if(this.screenAndroidProjection != null) {            this.screenAndroidProjection.close();        }//        this.screenAndroidProjection = new ScreenAndroidProjection(clientId, resourcePath, this);//        this.screenAndroidProjection.setZoom(scale);//        this.screenAndroidProjection.setRotate(rotate);//        this.screenAndroidProjection.setQuality(quality);//        this.screenAndroidProjection.initRecorder(outputFile);//        this.screenAndroidProjection.start();    }    public void startMinitouch() {        if(DeviceType.ANDROID.equals(this.deviceType)) {            if (this.touchProjection != null) {                this.touchProjection.close();            }            this.touchProjection = new TouchAndroidProjection(clientId, resourcePath);            this.touchProjection.start();        }else{            this.iosDriver = new IOSDriver(this.iosDriverCapabilities);        }    }    public void stopMinicap() {        if(DeviceType.ANDROID.equals(this.deviceType)) {            if (this.screenAndroidProjection != null) {                this.screenAndroidProjection.close();            }        }else{            if (this.screenIOSProjection != null) {                this.screenIOSProjection.close();            }        }    }    public void stopMinitouch() {        if(DeviceType.ANDROID.equals(this.deviceType)) {            if (this.touchProjection != null) {                this.touchProjection.close();            }        }else{            if(this.iosDriver != null) {                this.iosDriver.quit();                this.iosDriver = null;            }        }    }    public void keyevent(Integer code) {        if(DeviceType.ANDROID.equals(deviceType)) {            if (this.touchProjection != null) {                this.touchProjection.sendCode(code);            }        }        if(DeviceType.IOS.equals(deviceType)) {            if (code == KeyCode.KEYCODE_HOME){                if (this.iosDriver != null) {                    this.iosDriver.home();                }            }        }    }    public void touch( String command) {        if(DeviceType.ANDROID.equals(deviceType)){            if (this.touchProjection != null) {                this.touchProjection.sendEvent(command);            }        }        if(DeviceType.IOS.equals(deviceType)){            if(this.iosDriver != null) {                JSONObject params = JSON.parseObject(command);                Integer x = params.getInteger("x");                Integer y = params.getInteger("y");                this.iosDriver.tap(x, y);            }        }    }    public void inputText( String command) {        if(DeviceType.ANDROID.equals(deviceType)){            if (this.touchProjection != null) {                this.touchProjection.sendText(command);            }        }        if(DeviceType.IOS.equals(deviceType)){            if(this.iosDriver != null) {                this.iosDriver.input(command);            }        }    }    /**     * 等待时，关闭logcat     * @param     */    public void stopLogcat() {        if(this.dLogger != null){            this.dLogger.close();        }    }    /**     * 再次发送命令下来时，重新打开logcat     * @param command     */    public synchronized void startLogcat(String command) {        this.stopLogcat();        this.isLogcatWaitting = true;        if(StringUtils.isNotEmpty(command)) {            Map filterParams = JSON.parseObject(command, Map.class);            if(filterParams != null) {                String tag = (String) filterParams.getOrDefault("tag", "");                String pid = (String) filterParams.getOrDefault("pid", "");                Log.LogLevel level = Log.LogLevel.getByLetterString((String) filterParams.getOrDefault("level", "E"));                String message = (String) filterParams.get("message");                logCatFilter = new LogCatFilter(tag, message, pid, level);            }        }        if(dLogger == null || !dLogger.isRunning()) {            dLogger = new DLogger(this.clientId, this.deviceType, this);            dLogger.start();        }    }    @Override    public void onLog(byte[] bytes) {        try {            List<LogcatMessageRequest> logLines = new ArrayList<>();            if(DeviceType.ANDROID.equals(deviceType)){                logLines = getAndroidLogMessageRequests(bytes);            }            if(DeviceType.IOS.equals(deviceType)){                logLines = geIOSLogMessageRequests(bytes);            }            LogcatRequest request = LogcatRequest.newBuilder()                    .setSerial(clientId)                    .addAllMessages(logLines)                    .build();            Gvice.deviceService(this.channel).logcat(request);        }catch (Exception e){            log.error(e.getMessage());        }    }    private List<LogcatMessageRequest> getAndroidLogMessageRequests(byte[] bytes) {        List<LogcatMessageRequest> logLines = new ArrayList<>();        String logstr = new String(bytes, StandardCharsets.UTF_8).replace("\0", "");        String[] lines = logstr.split("\n");        for(String line : lines) {            // 正则解析 logstr            Matcher matcher = logAndroidPattern.matcher(line);            if(matcher.matches()){                String logData = matcher.group(1);                String logTime = matcher.group(2);                String logProcess = matcher.group(3);                String logThread = matcher.group(4);                Log.LogLevel logLevel = Log.LogLevel.getByLetterString(matcher.group(5));                if(logLevel == null) {                    continue;                }                String logTag = matcher.group(6);                String logMessage = matcher.group(7);                LogCatMessage logCatMessage = new LogCatMessage(logData, logTime, logProcess, logThread, logLevel, logTag, logMessage);                if(logCatFilter.matches(logCatMessage)) {                    LogcatMessageRequest messageRequest = LogcatMessageRequest.newBuilder()                                                            .setData(logData)                                                            .setTime(logTime)                                                            .setPid(logProcess)                                                            .setThread(logThread)                                                            .setLevel(logLevel.getStringValue())                                                            .setTag(logTag)                                                            .setMessage(logMessage)                                                            .build();                    logLines.add(messageRequest);                }            }        }        return logLines;    }    private List<LogcatMessageRequest> geIOSLogMessageRequests(byte[] bytes) {        List<LogcatMessageRequest> logLines = new ArrayList<>();        String logstr = new String(bytes, StandardCharsets.UTF_8).replace("\0", "");        String[] lines = logstr.split("\n");        for(String line : lines) {            // 正则解析 logstr            Matcher matcher = logIOSPattern.matcher(line);            if(matcher.matches()){                String logTime = matcher.group(2);                String logProcess = matcher.group(3);                String logThread = matcher.group(4);                String logData = matcher.group(5);                Log.LogLevel logLevel = Log.LogLevel.getByLetterString(matcher.group(5));                if(logLevel == null) {                    continue;                }                String logTag = matcher.group(6);                String logMessage = matcher.group(7);                LogCatMessage logCatMessage = new LogCatMessage(logData, logTime, logProcess, logThread, logLevel, logTag, logMessage);                if(logCatFilter.matches(logCatMessage)) {                    LogcatMessageRequest messageRequest = LogcatMessageRequest.newBuilder()                                                            .setData(logData)                                                            .setTime(logTime)                                                            .setPid(logProcess)                                                            .setThread(logThread)                                                            .setLevel(logLevel.getStringValue())                                                            .setTag(logTag)                                                            .setMessage(logMessage)                                                            .build();                    logLines.add(messageRequest);                }            }        }        return logLines;    }    /**     *@Description: 开始执行测试任务     *@Param: [shellCommand]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void startFunctionalTask(String command) {        log.info("设备 {}，开始任务 {}", clientId, command);        switchADBKeyBoard();        RemoteRunCommand cmd = JSON.parseObject(command, RemoteRunCommand.class);        defaultVideoRecorderStart(cmd.getTaskCode());        task = new FunctionalTestTask(cmd, this);        TaskDispatcher.getInstance().submit(task);    }    /**     * 兼容测试     */    public void startCompatibilityTask(String command) {        log.info("设备 {}，开始兼容任务 {}", clientId, command);        RemoteRunCommand cmd = JSON.parseObject(command, RemoteRunCommand.class);        defaultVideoRecorderStart(cmd.getTaskCode());        task = new CompatibilityAndroidTestTask(cmd, this);        TaskDispatcher.getInstance().submit(task);    }    /**     * 遍历测试     */    public void startCrawlerTask(String command) {        log.info("设备 {}，开始遍历任务 {}", clientId, command);        RemoteRunCommand cmd = JSON.parseObject(command, RemoteRunCommand.class);        defaultVideoRecorderStart(cmd.getTaskCode());        task = new CrawlerTestTask(cmd, this);        TaskDispatcher.getInstance().submit(task);    }    /**     *@Description: 取消在该设备正在执行的任务     *@Param: [shellCommand]     *@Return: void     *@Author: wen     *@Date: 2018/4/9     */    public void cancelTask(Long taskCode) {        if(task != null){            RemoteRunCommand cmd = task.getCMD();            if(taskCode.equals(cmd.getTaskCode())) {                task.terminate();                task = null;            }        }    }    /**     *@Description: 任务执行完成的回调     *@Param: []     *@Return: void     *@Author: wen     *@Date: 2018/7/10     */    @Override    public void taskFinish() {        if(this.screenAndroidProjection != null) {            this.screenAndroidProjection.close();            log.info("关闭屏幕映射 {} {} ", clientInfo.get().getBrand(), clientInfo.get().getDeviceId());            try {                TimeUnit.SECONDS.sleep(5);            } catch (InterruptedException e) {            }        }        switchOriginalKeyboard();    }    @Override    public byte[] takeFrame() {        if(DeviceType.ANDROID.equals(this.deviceType)){            if(this.screenAndroidProjection != null && this.screenAndroidProjection.isRunning()) {//                return this.screenAndroidProjection.frame();            }        }        return null;    }    @Override    public String getVideoFile() {        return this.videoOutputFile;    }    private void switchADBKeyBoard() {        if(DeviceType.ANDROID.equals(deviceType)) {            // 检查输入法是否已经安装            boolean isInstall = ADBCommandUtils.isInstalledBasepackage(clientId, "com.android.adbkeyboard");            if(!isInstall){                // install 支持中文输入的输入法                String resourcesPath = Config.getString("distest.agent.resources");                String keyboardPath = resourcesPath + File.separator + Constant.getKeyboardService();                if(Paths.get(keyboardPath).toFile().exists()){                    ADBCommandUtils.installApp(clientId, keyboardPath);                }            }else{                ADBCommandUtils.switchADBKeyBoard(clientId);            }        }    }    private void switchOriginalKeyboard() {        if(DeviceType.ANDROID.equals(deviceType)) {            ADBCommandUtils.switchOriginalKeyboard(clientId);        }    }    public DeviceType getDeviceType(){        return this.deviceType;    }    /**     * 执行`adb -u [deviceId] forward tcp:5555 tcp:5555`     * 执行`socat tcp4-listen:15555,fork,reuseaddr tcp-connect:127.0.0.1:5555`     */    public void debugStart() {        if(DeviceType.ANDROID.equals(deviceType)) {            // 执行转发命令            ADBCommandUtils.forwardTcp(this.clientId, this.tcpipPort, this.tcpipPort);            if(this.androidDebugServer == null) {                this.androidDebugServer = new AndroidDebugServer(this.clientId, this.tcpipPort, this.socatPort);            }            if(!this.androidDebugServer.isRunning()) {                this.androidDebugServer.start();            }        }    }    public void debugStop() {        if(DeviceType.ANDROID.equals(deviceType)) {            if(this.androidDebugServer.isRunning()) {                this.androidDebugServer.stop();            }        }    }    public void openWeb(String cmd) {        if(DeviceType.ANDROID.equals(deviceType)) {            ADBCommandUtils.openWeb(this.clientId, cmd);        }else{//            this.iosDriver.openWeb(cmd);        }    }}