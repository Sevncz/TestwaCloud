package com.testwa.distest.client.component.logcat;import com.android.ddmlib.Log;import lombok.Data;import lombok.NonNull;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.regex.PatternSyntaxException;/** * @Program: distest * @Description: * @Author: wen * @Create: 2018-08-02 15:46 **/@Datapublic class LogCatFilter {    private static final String PID_KEYWORD = "pid:";   //$NON-NLS-1$    private static final String APP_KEYWORD = "app:";   //$NON-NLS-1$    private static final String TAG_KEYWORD = "tag:";   //$NON-NLS-1$    private static final String TEXT_KEYWORD = "text:"; //$NON-NLS-1$    private final String mName;    private final String mTag;    private final String mText;    private final String mPid;    private final String mAppName;    private final Log.LogLevel mLogLevel;    private boolean mCheckPid;    private boolean mCheckAppName;    private boolean mCheckTag;    private boolean mCheckText;    private Pattern mAppNamePattern;    private Pattern mTagPattern;    private Pattern mTextPattern;    public LogCatFilter(@NonNull String tag, @NonNull String text, @NonNull String pid, @NonNull Log.LogLevel logLevel) {        mName = "";        mAppName = "";        mTag = tag.trim();        mText = text.trim();        mPid = pid.trim();        mLogLevel = logLevel;        mCheckPid = !mPid.isEmpty();        if (!mAppName.isEmpty()) {            try {                mAppNamePattern = Pattern.compile(mAppName, getPatternCompileFlags(mAppName));                mCheckAppName = true;            } catch (PatternSyntaxException e) {                mCheckAppName = false;            }        }        if (!mTag.isEmpty()) {            try {                mTagPattern = Pattern.compile(mTag, getPatternCompileFlags(mTag));                mCheckTag = true;            } catch (PatternSyntaxException e) {                mCheckTag = false;            }        }        if (!mText.isEmpty()) {            try {                mTextPattern = Pattern.compile(mText, getPatternCompileFlags(mText));                mCheckText = true;            } catch (PatternSyntaxException e) {                mCheckText = false;            }        }    }    public LogCatFilter(@NonNull String name, @NonNull String tag, @NonNull String text,                        @NonNull String pid, @NonNull String appName, @NonNull Log.LogLevel logLevel) {        mName = name.trim();        mTag = tag.trim();        mText = text.trim();        mPid = pid.trim();        mAppName = appName.trim();        mLogLevel = logLevel;        mCheckPid = !mPid.isEmpty();        if (!mAppName.isEmpty()) {            try {                mAppNamePattern = Pattern.compile(mAppName, getPatternCompileFlags(mAppName));                mCheckAppName = true;            } catch (PatternSyntaxException e) {                mCheckAppName = false;            }        }        if (!mTag.isEmpty()) {            try {                mTagPattern = Pattern.compile(mTag, getPatternCompileFlags(mTag));                mCheckTag = true;            } catch (PatternSyntaxException e) {                mCheckTag = false;            }        }        if (!mText.isEmpty()) {            try {                mTextPattern = Pattern.compile(mText, getPatternCompileFlags(mText));                mCheckText = true;            } catch (PatternSyntaxException e) {                mCheckText = false;            }        }    }    private int getPatternCompileFlags(String regex) {        for (char c : regex.toCharArray()) {            if (Character.isUpperCase(c)) {                return 0;            }        }        return Pattern.CASE_INSENSITIVE;    }    public static List<LogCatFilter> fromString(String query, Log.LogLevel minLevel) {        List<LogCatFilter> filterSettings = new ArrayList<>();        for (String s : query.trim().split(" ")) {            String tag = "";            String text = "";            String pid = "";            String app = "";            if (s.startsWith(PID_KEYWORD)) {                pid = s.substring(PID_KEYWORD.length());            } else if (s.startsWith(APP_KEYWORD)) {                app = s.substring(APP_KEYWORD.length());            } else if (s.startsWith(TAG_KEYWORD)) {                tag = s.substring(TAG_KEYWORD.length());            } else {                if (s.startsWith(TEXT_KEYWORD)) {                    text = s.substring(TEXT_KEYWORD.length());                } else {                    text = s;                }            }            filterSettings.add(new LogCatFilter("livefilter-" + s,                    tag, text, pid, app, minLevel));        }        return filterSettings;    }    public boolean matches(LogCatMessage m) {        /* filter out messages of a lower priority */        if (m.getLevel().getPriority() < mLogLevel.getPriority()) {            return false;        }        /* if pid filter is enabled, filter out messages whose pid does not match         * the filter's pid */        if (mCheckPid && !m.getPid().equals(mPid)) {            return false;        }        /* if app name filter is enabled, filter out messages not matching the app name *///        if (mCheckAppName) {//            Matcher matcher = mAppNamePattern.matcher(m.getAppName());//            if (!matcher.find()) {//                return false;//            }//        }        /* if tag filter is enabled, filter out messages not matching the tag */        if (mCheckTag) {            Matcher matcher = mTagPattern.matcher(m.getTag());            if (!matcher.find()) {                return false;            }        }        if (mCheckText) {            Matcher matcher = mTextPattern.matcher(m.getMessage());            if (!matcher.find()) {                return false;            }        }        return true;    }}