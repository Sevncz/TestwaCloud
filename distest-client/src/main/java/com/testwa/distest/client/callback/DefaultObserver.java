package com.testwa.distest.client.callback;import com.testwa.distest.client.DeviceClient;import com.testwa.distest.client.callback.CallBackUtils;import com.testwa.distest.client.callback.ICallBack;import io.grpc.stub.StreamObserver;import io.rpc.testwa.push.Message;import lombok.extern.slf4j.Slf4j;import java.net.SocketException;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.Executor;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;@Slf4jpublic class DefaultObserver implements StreamObserver<Message> {	private DeviceClient client; // 用于回调客户端信息	private String info;  // clientId    private volatile ConcurrentHashMap<Message.Topic, ICallBack> cache = new ConcurrentHashMap<>();	public DefaultObserver(String info, DeviceClient client){		this.info = info;		this.client = client;	}		@Override	public void onCompleted() {		log.debug(info +" onCompleted");	}	@Override	public void onError(Throwable arg0) {		log.info("{} connect retry ... ... {}", info, arg0);        try {            TimeUnit.MILLISECONDS.sleep(10000);        } catch (InterruptedException e) {            e.printStackTrace();        }		client.resendRegister(this);    }	@SuppressWarnings("rawtypes")	@Override	public void onNext(Message message) {		log.debug(info +",{topicName:"+message.getTopicName()+",getSource:"+message.getStatus()+"}");		ICallBack call;		try {		    if(cache.containsKey(message.getTopicName())){                call = cache.get(message.getTopicName());            }else{                call = CallBackUtils.getCallBack(message.getTopicName(), client);                cache.put(message.getTopicName(), call);            }			call.callback(message.getMessage());		} catch (Exception e) {			log.error("回调错误", e);		}	}}