package com.testwa.distest.client.control.client.callback;import com.testwa.distest.client.control.client.DeviceClient;import com.testwa.distest.client.control.client.callback.CallBackUtils;import com.testwa.distest.client.control.client.callback.ICallBack;import io.grpc.stub.StreamObserver;import io.rpc.testwa.push.Message;import lombok.extern.slf4j.Slf4j;import java.net.SocketException;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;@Slf4jpublic class DefaultObserver implements StreamObserver<Message> {	private DeviceClient client; // 用于回调客户端信息	private String info;  // clientId    private volatile ConcurrentHashMap<Message.Topic, ICallBack> cache = new ConcurrentHashMap<>();		public DefaultObserver(String info, DeviceClient client){		this.info = info;		this.client = client;	}		@Override	public void onCompleted() {		log.info(info +" onCompleted");	}	@Override	public void onError(Throwable arg0) {		log.info(info +" onError");	}	@SuppressWarnings("rawtypes")	@Override	public void onNext(Message message) {		log.info(info +",{topicName:"+message.getTopicName()+",status:"+message.getStatus()+"}");		ICallBack call;		try {		    if(cache.containsKey(message.getTopicName())){                call = cache.get(message.getTopicName());            }else{                call = CallBackUtils.getCallBack(message.getTopicName(), client);                cache.put(message.getTopicName(), call);            }			call.callback(message.getMessage());		} catch (Exception e) {			log.error(e.getLocalizedMessage());		}	}}