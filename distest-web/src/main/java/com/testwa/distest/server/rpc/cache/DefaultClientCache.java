package com.testwa.distest.server.rpc.cache;import java.util.Map.Entry;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import io.grpc.stub.StreamObserver;import io.rpc.testwa.agent.ClientInfo;import io.rpc.testwa.agent.Status;public class DefaultClientCache<T> implements IClientCache<T> {		private volatile ConcurrentHashMap<String, StreamObserver<T>> cache = new ConcurrentHashMap<String, StreamObserver<T>>();	@Override	public void registerToServer(ClientInfo clientInfo, StreamObserver<T> observer) {		cache.put(clientInfo.getDeviceId(), observer);	}    @Override	public Status logoutFromServer(ClientInfo clientInfo) {		StreamObserver<T> ob = getObserver(clientInfo);		if(null!=ob){			ob.onCompleted();			cache.remove(clientInfo.getDeviceId());		}		return Status.newBuilder().setStatus("OK").build();	}    @Override	public void clearErrorObserver() {		Set<Entry<String, StreamObserver<T>>> set = cache.entrySet();		for (Entry<String, StreamObserver<T>> entry : set) {			StreamObserver<T> observer = entry.getValue();			//暂时不知道判断		}	}	@Override	public StreamObserver<T> getObserver(ClientInfo clientInfo) {		return getObserver(clientInfo.getDeviceId());	}	@Override	public boolean removeErrorObserver(String clientId) {		cache.remove(clientId);		return true;	}	@Override	public StreamObserver<T> getObserver(String clientId) {		return cache.get(clientId);	}}