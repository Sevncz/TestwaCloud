package com.testwa.core.shell;import lombok.extern.slf4j.Slf4j;import org.apache.commons.exec.*;import java.io.*;import java.nio.file.Path;/** * @Program: distest * @Description: 支持字符编码设置 * @Author: wen * @Create: 2018-04-17 11:30 **/@Slf4jpublic class UTF8CommonExecs extends AbstractCommonExecs{    private CommandLine commandLine;    private Boolean isEncode;    private Long timeout = 20000L;    private ByteArrayOutputStream outputStream;    private ByteArrayOutputStream errorStream;    private ExecuteWatchdog watchdog;    /**     *@Description:     *@Param: [commandLine]     *@Return:     *@Author: wen     *@Date:     */    public UTF8CommonExecs(CommandLine commandLine) {        super(commandLine);        this.commandLine = commandLine;    }    @Override    public boolean supportWatchdog() {        return true;    }    @Override    public ExecuteWatchdog getWatchdog() {        watchdog = new ExecuteWatchdog(timeout);        return watchdog;    }    public void setTimeout(Long timeout){        this.timeout = timeout;    }    public void unableEncoding() {        isEncode = false;    }    public void ableEncoding() {        isEncode = true;    }    public String getEncoding() {        return "UTF-8";    }    public String getOutput(){        String out = "";        try {            if(outputStream != null){                out = outputStream.toString(getEncoding()); //设置编码            }        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }        return out;    }    public String getError(){        String error = "";        try {            if(outputStream != null){                error = errorStream.toString(getEncoding()); //设置编码            }        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }        return error;    }    public void exec() throws IOException {        DefaultExecutor executor = buildDefaultExecutor();        executor.execute(this.commandLine);    }    public void asyncexec() throws IOException {        DefaultExecutor executor = buildDefaultExecutor();        executor.execute(this.commandLine, new DefaultExecuteResultHandler());    }    private DefaultExecutor buildDefaultExecutor() {        outputStream = new ByteArrayOutputStream();        errorStream = new ByteArrayOutputStream();        DefaultExecutor executor = new DefaultExecutor();        if(supportWatchdog()) {            executor.setWatchdog(getWatchdog());        }        PumpStreamHandler streamHandler = new PumpStreamHandler(outputStream, errorStream);        executor.setStreamHandler(streamHandler);        executor.setProcessDestroyer(new ShutdownHookProcessDestroyer());        return executor;    }    public void destroy(){        if(watchdog != null) {            watchdog.destroyProcess();            log.info("watchdog killed the process {}", watchdog.killedProcess());        }    }    public void outputToFile(Path savePath){        if(watchdog != null && !watchdog.killedProcess()){            OutputStream fileOutputStream = null;            try {                fileOutputStream = new FileOutputStream(savePath.toFile());                outputStream.writeTo(fileOutputStream);            } catch (IOException e) {                e.printStackTrace();            }finally {                try {                    fileOutputStream.close();                } catch (IOException e) {                }            }        }    }}